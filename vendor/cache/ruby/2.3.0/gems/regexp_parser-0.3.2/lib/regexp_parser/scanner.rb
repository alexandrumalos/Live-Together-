
# line 1 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"

# line 769 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"


# THIS IS A GENERATED FILE, DO NOT EDIT DIRECTLY
# This file was generated from lib/regexp_parser/scanner/scanner.rl

module Regexp::Scanner
  
# line 13 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner.rb"
class << self
	attr_accessor :_re_scanner_trans_keys
	private :_re_scanner_trans_keys, :_re_scanner_trans_keys=
end
self._re_scanner_trans_keys = [
	0, 0, -128, -65, -128, -65, 
	-128, -65, -128, -65, -128, 
	-65, -128, -65, 10, 10, 
	33, 120, 41, 41, 41, 41, 
	39, 122, 33, 122, 48, 
	122, 39, 60, 39, 122, 
	48, 57, 39, 57, 48, 57, 
	39, 57, 39, 122, 43, 
	122, 48, 57, 48, 62, 
	48, 57, 43, 62, 43, 122, 
	44, 125, 48, 125, 123, 
	123, 9, 122, 9, 125, 
	9, 125, 9, 125, 9, 125, 
	49, 55, 46, 46, 49, 
	49, 125, 125, 46, 46, 
	48, 49, 46, 46, 48, 50, 
	46, 46, 48, 51, 46, 
	46, 48, 48, 9, 122, 
	-128, -65, -128, -65, -128, -65, 
	-128, -65, -128, -65, -128, 
	-65, 48, 122, 45, 122, 
	45, 122, 93, 93, 94, 120, 
	97, 120, 108, 115, 110, 
	112, 117, 117, 109, 109, 
	58, 58, 93, 93, 104, 104, 
	97, 97, 99, 99, 105, 
	105, 105, 105, 108, 108, 
	97, 97, 110, 110, 107, 107, 
	110, 110, 116, 116, 114, 
	114, 108, 108, 105, 105, 
	103, 103, 105, 105, 116, 116, 
	114, 114, 97, 97, 112, 
	112, 104, 104, 111, 111, 
	119, 119, 101, 101, 114, 114, 
	114, 117, 105, 105, 110, 
	110, 110, 110, 99, 99, 
	112, 112, 97, 97, 99, 99, 
	101, 101, 112, 112, 112, 
	112, 111, 111, 114, 114, 
	100, 100, 100, 100, 65, 122, 
	61, 61, 93, 93, -128, 
	-65, -128, -65, -128, -65, 
	-128, -65, -128, -65, -128, -65, 
	92, 92, 120, 120, 48, 
	102, 45, 45, 45, 45, 
	67, 99, 45, 45, 48, 123, 
	48, 102, 48, 102, 48, 
	102, 48, 102, 48, 102, 
	48, 102, 48, 102, 9, 125, 
	48, 125, 48, 123, 9, 
	125, 9, 125, 41, 41, 
	39, 122, 41, 57, 48, 122, 
	-62, 127, -62, -33, -32, 
	-17, -16, -12, 1, 127, 
	1, 127, 9, 32, 33, 126, 
	10, 126, 63, 63, 43, 
	63, 43, 63, 43, 63, 
	65, 122, 43, 63, 80, 112, 
	-62, 127, -128, -65, -62, 
	-33, -128, -65, -32, -17, 
	-128, -65, -16, -12, 1, 127, 
	38, 38, 93, 93, 45, 
	45, 46, 61, -62, 127, 
	-62, -33, -32, -17, -16, -12, 
	1, 127, 32, 126, 32, 
	126, 32, 126, 48, 102, 
	32, 126, 36, 125, 48, 55, 
	48, 55, 92, 92, 48, 
	102, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 
	125, 9, 125, 9, 125, 
	9, 125, 9, 125, 9, 125, 
	9, 125, 9, 125, 9, 
	32, 9, 125, 48, 125, 
	48, 125, 48, 125, 48, 125, 
	48, 125, 48, 125, 48, 
	125, 125, 125, 39, 60, 
	39, 122, 49, 57, 41, 57, 
	48, 122, 0
]

class << self
	attr_accessor :_re_scanner_key_spans
	private :_re_scanner_key_spans, :_re_scanner_key_spans=
end
self._re_scanner_key_spans = [
	0, 64, 64, 64, 64, 64, 64, 1, 
	88, 1, 1, 84, 90, 75, 22, 84, 
	10, 19, 10, 19, 84, 80, 10, 15, 
	10, 20, 80, 82, 78, 1, 114, 117, 
	117, 117, 117, 7, 1, 1, 1, 1, 
	2, 1, 3, 1, 4, 1, 1, 114, 
	64, 64, 64, 64, 64, 64, 75, 78, 
	78, 1, 27, 24, 8, 3, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 4, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 58, 1, 1, 64, 64, 64, 
	64, 64, 64, 1, 1, 55, 1, 1, 
	33, 1, 76, 55, 55, 55, 55, 55, 
	55, 55, 117, 78, 76, 117, 117, 1, 
	84, 17, 75, 190, 30, 16, 5, 127, 
	127, 24, 94, 117, 1, 21, 21, 21, 
	58, 21, 33, 190, 64, 30, 64, 16, 
	64, 5, 127, 1, 1, 1, 16, 190, 
	30, 16, 5, 127, 95, 95, 95, 55, 
	95, 90, 8, 8, 1, 55, 1, 1, 
	1, 1, 1, 1, 1, 1, 117, 117, 
	117, 117, 117, 117, 117, 24, 117, 78, 
	78, 78, 78, 78, 78, 78, 1, 22, 
	84, 9, 17, 75
]

class << self
	attr_accessor :_re_scanner_index_offsets
	private :_re_scanner_index_offsets, :_re_scanner_index_offsets=
end
self._re_scanner_index_offsets = [
	0, 0, 65, 130, 195, 260, 325, 390, 
	392, 481, 483, 485, 570, 661, 737, 760, 
	845, 856, 876, 887, 907, 992, 1073, 1084, 
	1100, 1111, 1132, 1213, 1296, 1375, 1377, 1492, 
	1610, 1728, 1846, 1964, 1972, 1974, 1976, 1978, 
	1980, 1983, 1985, 1989, 1991, 1996, 1998, 2000, 
	2115, 2180, 2245, 2310, 2375, 2440, 2505, 2581, 
	2660, 2739, 2741, 2769, 2794, 2803, 2807, 2809, 
	2811, 2813, 2815, 2817, 2819, 2821, 2823, 2825, 
	2827, 2829, 2831, 2833, 2835, 2837, 2839, 2841, 
	2843, 2845, 2847, 2849, 2851, 2853, 2855, 2857, 
	2859, 2861, 2863, 2865, 2870, 2872, 2874, 2876, 
	2878, 2880, 2882, 2884, 2886, 2888, 2890, 2892, 
	2894, 2896, 2898, 2957, 2959, 2961, 3026, 3091, 
	3156, 3221, 3286, 3351, 3353, 3355, 3411, 3413, 
	3415, 3449, 3451, 3528, 3584, 3640, 3696, 3752, 
	3808, 3864, 3920, 4038, 4117, 4194, 4312, 4430, 
	4432, 4517, 4535, 4611, 4802, 4833, 4850, 4856, 
	4984, 5112, 5137, 5232, 5350, 5352, 5374, 5396, 
	5418, 5477, 5499, 5533, 5724, 5789, 5820, 5885, 
	5902, 5967, 5973, 6101, 6103, 6105, 6107, 6124, 
	6315, 6346, 6363, 6369, 6497, 6593, 6689, 6785, 
	6841, 6937, 7028, 7037, 7046, 7048, 7104, 7106, 
	7108, 7110, 7112, 7114, 7116, 7118, 7120, 7238, 
	7356, 7474, 7592, 7710, 7828, 7946, 7971, 8089, 
	8168, 8247, 8326, 8405, 8484, 8563, 8642, 8644, 
	8667, 8752, 8762, 8780
]

class << self
	attr_accessor :_re_scanner_indicies
	private :_re_scanner_indicies, :_re_scanner_indicies=
end
self._re_scanner_indicies = [
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	0, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 0, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 0, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 0, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 0, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 0, 9, 8, 
	11, 10, 12, 10, 10, 10, 13, 14, 
	10, 10, 10, 10, 15, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 16, 10, 17, 11, 16, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	15, 10, 10, 15, 10, 10, 10, 10, 
	15, 10, 10, 10, 15, 10, 10, 10, 
	10, 10, 10, 10, 15, 10, 10, 15, 
	10, 10, 18, 19, 18, 16, 10, 10, 
	10, 10, 10, 10, 10, 10, 13, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	10, 10, 10, 10, 10, 10, 10, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 10, 10, 10, 10, 13, 10, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 10, 11, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 10, 10, 10, 11, 16, 
	10, 10, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 10, 10, 10, 10, 
	20, 10, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 10, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 10, 
	10, 10, 10, 16, 10, 10, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	10, 10, 10, 10, 20, 10, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	10, 22, 21, 21, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 23, 21, 
	24, 21, 21, 21, 25, 21, 26, 21, 
	21, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 21, 21, 21, 21, 21, 
	21, 21, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 21, 21, 21, 21, 
	27, 21, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 21, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 21, 
	24, 21, 21, 21, 21, 21, 21, 21, 
	21, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 21, 28, 29, 29, 29, 
	29, 29, 29, 29, 29, 29, 21, 24, 
	21, 21, 21, 25, 21, 25, 21, 21, 
	29, 29, 29, 29, 29, 29, 29, 29, 
	29, 29, 21, 24, 21, 21, 21, 25, 
	21, 25, 21, 21, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 21, 21, 
	21, 21, 21, 21, 21, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 21, 
	21, 21, 21, 27, 21, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 21, 
	30, 21, 31, 21, 21, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 21, 
	21, 21, 21, 24, 21, 21, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	21, 21, 21, 21, 32, 21, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	21, 33, 33, 33, 33, 33, 33, 33, 
	33, 33, 33, 21, 33, 33, 33, 33, 
	33, 33, 33, 33, 33, 33, 21, 21, 
	21, 21, 24, 21, 33, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 21, 30, 
	21, 30, 21, 21, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 21, 21, 
	21, 21, 24, 21, 30, 21, 30, 21, 
	21, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 21, 21, 21, 21, 24, 
	21, 21, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 21, 21, 21, 21, 
	32, 21, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 21, 36, 35, 35, 
	35, 37, 37, 37, 37, 37, 37, 37, 
	37, 37, 37, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 38, 35, 
	36, 36, 36, 36, 36, 36, 36, 36, 
	36, 36, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 38, 35, 39, 
	40, 41, 41, 41, 41, 41, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	41, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 41, 40, 40, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 40, 40, 40, 40, 40, 40, 
	40, 42, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 40, 40, 40, 43, 41, 
	40, 42, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 40, 41, 41, 41, 41, 
	41, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 41, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	41, 40, 40, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 40, 40, 40, 
	40, 40, 40, 40, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 40, 40, 
	40, 40, 41, 40, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 40, 40, 
	44, 40, 41, 41, 41, 41, 41, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 41, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 41, 40, 
	40, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 40, 40, 40, 40, 40, 
	40, 40, 41, 41, 41, 41, 41, 41, 
	45, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 40, 40, 40, 40, 
	41, 40, 41, 41, 41, 41, 41, 41, 
	45, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 40, 40, 44, 40, 
	41, 41, 41, 41, 41, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 41, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 41, 40, 40, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 40, 40, 40, 40, 40, 40, 40, 
	41, 41, 41, 41, 46, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 40, 40, 40, 40, 41, 40, 
	41, 41, 41, 41, 46, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 40, 40, 44, 40, 41, 41, 
	41, 41, 41, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 41, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 41, 40, 40, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 40, 
	40, 40, 47, 40, 40, 40, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	40, 40, 40, 40, 41, 40, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	40, 40, 44, 40, 48, 49, 50, 49, 
	50, 51, 52, 40, 53, 40, 54, 40, 
	44, 40, 55, 40, 54, 54, 40, 56, 
	40, 54, 54, 54, 40, 57, 40, 54, 
	54, 54, 54, 40, 58, 40, 54, 40, 
	41, 41, 41, 41, 41, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 41, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 41, 40, 40, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 40, 40, 40, 40, 40, 40, 40, 
	42, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 40, 40, 40, 40, 41, 40, 
	42, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 40, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 59, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 59, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 59, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 59, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 59, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	59, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 59, 59, 59, 59, 59, 
	59, 59, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 59, 59, 59, 59, 
	59, 59, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 59, 69, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 68, 68, 68, 68, 68, 
	68, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 68, 69, 70, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 68, 68, 68, 68, 68, 68, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 68, 71, 68, 72, 68, 68, 
	73, 74, 75, 76, 68, 68, 77, 68, 
	68, 68, 68, 78, 68, 68, 68, 79, 
	68, 68, 80, 68, 81, 68, 82, 83, 
	68, 73, 74, 75, 76, 68, 68, 77, 
	68, 68, 68, 68, 78, 68, 68, 68, 
	79, 68, 68, 80, 68, 81, 68, 82, 
	83, 68, 84, 68, 68, 68, 68, 68, 
	68, 85, 68, 86, 68, 87, 68, 88, 
	68, 89, 68, 90, 68, 91, 68, 92, 
	68, 89, 68, 93, 68, 94, 68, 89, 
	68, 95, 68, 96, 68, 97, 68, 89, 
	68, 98, 68, 99, 68, 100, 68, 89, 
	68, 101, 68, 102, 68, 103, 68, 89, 
	68, 104, 68, 105, 68, 106, 68, 89, 
	68, 107, 68, 108, 68, 109, 68, 89, 
	68, 110, 68, 68, 111, 68, 112, 68, 
	103, 68, 113, 68, 103, 68, 114, 68, 
	115, 68, 116, 68, 89, 68, 117, 68, 
	108, 68, 118, 68, 119, 68, 89, 68, 
	76, 68, 120, 120, 120, 120, 120, 120, 
	120, 120, 120, 120, 120, 120, 120, 120, 
	120, 120, 120, 120, 120, 120, 120, 120, 
	120, 120, 120, 120, 68, 68, 68, 68, 
	68, 68, 120, 120, 120, 120, 120, 120, 
	120, 120, 120, 120, 120, 120, 120, 120, 
	120, 120, 120, 120, 120, 120, 120, 120, 
	120, 120, 120, 120, 68, 121, 68, 122, 
	68, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 123, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 123, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 123, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 123, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 123, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 123, 131, 
	130, 132, 130, 133, 133, 133, 133, 133, 
	133, 133, 133, 133, 133, 130, 130, 130, 
	130, 130, 130, 130, 133, 133, 133, 133, 
	133, 133, 130, 130, 130, 130, 130, 130, 
	130, 130, 130, 130, 130, 130, 130, 130, 
	130, 130, 130, 130, 130, 130, 130, 130, 
	130, 130, 130, 130, 133, 133, 133, 133, 
	133, 133, 130, 134, 40, 135, 40, 138, 
	137, 137, 137, 137, 137, 137, 137, 137, 
	137, 137, 137, 137, 137, 137, 137, 137, 
	137, 137, 137, 137, 137, 137, 137, 137, 
	137, 137, 137, 137, 137, 137, 137, 139, 
	137, 139, 137, 140, 140, 140, 140, 140, 
	140, 140, 140, 140, 140, 40, 40, 40, 
	40, 40, 40, 40, 140, 140, 140, 140, 
	140, 140, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 140, 140, 140, 140, 
	140, 140, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 141, 40, 
	142, 142, 142, 142, 142, 142, 142, 142, 
	142, 142, 40, 40, 40, 40, 40, 40, 
	40, 142, 142, 142, 142, 142, 142, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 142, 142, 142, 142, 142, 142, 40, 
	143, 143, 143, 143, 143, 143, 143, 143, 
	143, 143, 40, 40, 40, 40, 40, 40, 
	40, 143, 143, 143, 143, 143, 143, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 143, 143, 143, 143, 143, 143, 40, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 40, 40, 40, 40, 40, 40, 
	40, 144, 144, 144, 144, 144, 144, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 144, 144, 144, 144, 144, 144, 40, 
	145, 145, 145, 145, 145, 145, 145, 145, 
	145, 145, 40, 40, 40, 40, 40, 40, 
	40, 145, 145, 145, 145, 145, 145, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 145, 145, 145, 145, 145, 145, 40, 
	146, 146, 146, 146, 146, 146, 146, 146, 
	146, 146, 40, 40, 40, 40, 40, 40, 
	40, 146, 146, 146, 146, 146, 146, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 146, 146, 146, 146, 146, 146, 40, 
	147, 147, 147, 147, 147, 147, 147, 147, 
	147, 147, 40, 40, 40, 40, 40, 40, 
	40, 147, 147, 147, 147, 147, 147, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 147, 147, 147, 147, 147, 147, 40, 
	148, 148, 148, 148, 148, 148, 148, 148, 
	148, 148, 40, 40, 40, 40, 40, 40, 
	40, 148, 148, 148, 148, 148, 148, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 148, 148, 148, 148, 148, 148, 40, 
	149, 149, 149, 149, 149, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 149, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 145, 
	145, 145, 145, 145, 145, 145, 145, 145, 
	145, 40, 40, 40, 40, 40, 40, 40, 
	145, 145, 145, 145, 145, 145, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	145, 145, 145, 145, 145, 145, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 144, 40, 145, 145, 
	145, 145, 145, 145, 145, 145, 145, 145, 
	40, 40, 40, 40, 40, 40, 40, 145, 
	145, 145, 145, 145, 145, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 145, 
	145, 145, 145, 145, 145, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 144, 40, 151, 151, 151, 
	151, 151, 151, 151, 151, 151, 151, 150, 
	150, 150, 150, 150, 150, 150, 151, 151, 
	151, 151, 151, 151, 150, 150, 150, 150, 
	150, 150, 150, 150, 150, 150, 150, 150, 
	150, 150, 150, 150, 150, 150, 150, 150, 
	150, 150, 150, 150, 150, 150, 151, 151, 
	151, 151, 151, 151, 150, 150, 150, 150, 
	150, 150, 150, 150, 150, 150, 150, 150, 
	150, 150, 150, 150, 150, 150, 150, 150, 
	152, 150, 154, 154, 154, 154, 154, 153, 
	153, 153, 153, 153, 153, 153, 153, 153, 
	153, 153, 153, 153, 153, 153, 153, 153, 
	153, 154, 153, 153, 153, 153, 153, 153, 
	153, 153, 153, 153, 153, 153, 153, 153, 
	153, 155, 155, 155, 155, 155, 155, 155, 
	155, 155, 155, 153, 153, 153, 153, 153, 
	153, 153, 155, 155, 155, 155, 155, 155, 
	153, 153, 153, 153, 153, 153, 153, 153, 
	153, 153, 153, 153, 153, 153, 153, 153, 
	153, 153, 153, 153, 153, 153, 153, 153, 
	153, 153, 155, 155, 155, 155, 155, 155, 
	153, 153, 153, 153, 153, 153, 153, 153, 
	153, 153, 153, 153, 153, 153, 153, 153, 
	153, 153, 153, 153, 153, 153, 156, 153, 
	158, 158, 158, 158, 158, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 158, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 157, 157, 157, 157, 
	157, 157, 157, 157, 156, 157, 160, 159, 
	161, 159, 159, 159, 159, 159, 159, 159, 
	159, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 159, 159, 159, 159, 159, 
	159, 159, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 159, 159, 159, 159, 
	162, 159, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 159, 160, 159, 159, 
	159, 159, 159, 159, 163, 163, 163, 163, 
	163, 163, 163, 163, 163, 163, 159, 164, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 159, 159, 159, 159, 161, 159, 159, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 159, 159, 159, 159, 164, 159, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 159, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 
	165, 166, 166, 166, 166, 166, 166, 166, 
	166, 166, 166, 166, 166, 166, 166, 166, 
	166, 167, 167, 167, 167, 167, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 168, 168, 168, 168, 168, 168, 
	168, 168, 169, 169, 169, 169, 169, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 170, 171, 171, 172, 173, 171, 171, 
	171, 174, 175, 176, 177, 171, 171, 178, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	179, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 180, 181, 35, 182, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 37, 183, 35, 171, 
	168, 35, 165, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 
	184, 166, 166, 166, 166, 166, 166, 166, 
	166, 166, 166, 166, 166, 166, 166, 166, 
	166, 184, 167, 167, 167, 167, 167, 184, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 184, 184, 
	184, 184, 184, 184, 184, 184, 168, 184, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	169, 169, 169, 169, 169, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 170, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 168, 185, 
	170, 170, 170, 170, 170, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 185, 
	185, 185, 185, 185, 185, 185, 185, 170, 
	185, 171, 171, 171, 184, 171, 171, 171, 
	184, 184, 184, 184, 171, 171, 184, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 184, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 184, 184, 184, 184, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 184, 184, 184, 171, 184, 
	9, 8, 8, 8, 8, 8, 8, 8, 
	8, 8, 8, 8, 8, 8, 8, 8, 
	8, 8, 8, 8, 8, 8, 8, 172, 
	172, 172, 8, 172, 172, 172, 8, 8, 
	8, 8, 172, 172, 8, 172, 172, 172, 
	172, 172, 172, 172, 172, 172, 172, 172, 
	172, 172, 172, 172, 172, 8, 172, 172, 
	172, 172, 172, 172, 172, 172, 172, 172, 
	172, 172, 172, 172, 172, 172, 172, 172, 
	172, 172, 172, 172, 172, 172, 172, 172, 
	172, 8, 8, 8, 8, 172, 172, 172, 
	172, 172, 172, 172, 172, 172, 172, 172, 
	172, 172, 172, 172, 172, 172, 172, 172, 
	172, 172, 172, 172, 172, 172, 172, 172, 
	172, 8, 8, 8, 172, 8, 187, 186, 
	189, 188, 188, 188, 188, 188, 188, 188, 
	188, 188, 188, 188, 188, 188, 188, 188, 
	188, 188, 188, 188, 189, 188, 191, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 191, 190, 193, 192, 192, 192, 
	192, 192, 192, 192, 192, 192, 192, 192, 
	192, 192, 192, 192, 192, 192, 192, 192, 
	193, 192, 195, 195, 194, 196, 194, 194, 
	195, 196, 194, 194, 197, 194, 194, 194, 
	194, 194, 194, 194, 196, 194, 194, 194, 
	196, 194, 194, 195, 194, 194, 194, 194, 
	194, 194, 194, 195, 194, 196, 194, 194, 
	198, 196, 194, 194, 198, 194, 194, 194, 
	194, 194, 194, 194, 196, 194, 194, 194, 
	196, 194, 194, 195, 194, 200, 199, 199, 
	199, 199, 199, 199, 199, 199, 199, 199, 
	199, 199, 199, 199, 199, 199, 199, 199, 
	199, 200, 199, 201, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 201, 40, 203, 203, 203, 
	203, 203, 203, 203, 203, 203, 203, 203, 
	203, 203, 203, 203, 203, 203, 203, 203, 
	203, 203, 203, 203, 203, 203, 203, 203, 
	203, 203, 203, 204, 204, 204, 204, 204, 
	204, 204, 204, 204, 204, 204, 204, 204, 
	204, 204, 204, 205, 205, 205, 205, 205, 
	202, 202, 202, 202, 202, 202, 202, 202, 
	202, 202, 202, 202, 206, 206, 206, 206, 
	206, 206, 206, 206, 206, 206, 206, 206, 
	206, 206, 206, 206, 206, 206, 206, 206, 
	206, 206, 206, 206, 206, 206, 206, 206, 
	206, 206, 206, 202, 202, 202, 202, 207, 
	202, 208, 202, 207, 207, 207, 207, 202, 
	209, 207, 202, 210, 210, 210, 210, 210, 
	210, 210, 210, 210, 210, 202, 202, 202, 
	202, 202, 207, 202, 210, 210, 210, 210, 
	210, 210, 210, 210, 210, 210, 210, 210, 
	210, 210, 210, 210, 210, 210, 210, 210, 
	210, 210, 210, 210, 210, 210, 211, 212, 
	213, 214, 202, 202, 210, 210, 210, 210, 
	210, 210, 210, 210, 210, 210, 210, 210, 
	210, 210, 210, 210, 210, 210, 210, 210, 
	210, 210, 210, 210, 210, 210, 207, 207, 
	207, 202, 206, 202, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 215, 216, 216, 216, 
	216, 216, 216, 216, 216, 216, 216, 216, 
	216, 216, 216, 216, 216, 216, 216, 216, 
	216, 216, 216, 216, 216, 216, 216, 216, 
	216, 216, 216, 215, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 215, 217, 217, 217, 
	217, 217, 217, 217, 217, 217, 217, 217, 
	217, 217, 217, 217, 217, 215, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 215, 218, 
	218, 218, 218, 218, 215, 206, 206, 206, 
	206, 206, 206, 206, 206, 206, 206, 206, 
	206, 206, 206, 206, 206, 206, 206, 206, 
	206, 206, 206, 206, 206, 206, 206, 206, 
	206, 206, 206, 206, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 206, 215, 219, 215, 220, 
	215, 221, 215, 224, 223, 223, 223, 223, 
	223, 223, 223, 223, 223, 223, 223, 225, 
	223, 223, 226, 223, 227, 227, 227, 227, 
	227, 227, 227, 227, 227, 227, 227, 227, 
	227, 227, 227, 227, 227, 227, 227, 227, 
	227, 227, 227, 227, 227, 227, 227, 227, 
	227, 227, 228, 228, 228, 228, 228, 228, 
	228, 228, 228, 228, 228, 228, 228, 228, 
	228, 228, 229, 229, 229, 229, 229, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 231, 231, 231, 231, 232, 231, 
	231, 231, 232, 232, 232, 232, 233, 232, 
	232, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 232, 231, 231, 231, 231, 234, 231, 
	231, 231, 234, 231, 231, 231, 231, 231, 
	231, 231, 235, 231, 231, 234, 231, 231, 
	231, 234, 231, 231, 231, 232, 232, 232, 
	232, 231, 231, 231, 236, 231, 234, 231, 
	231, 231, 234, 231, 231, 231, 231, 231, 
	231, 231, 235, 231, 231, 234, 231, 231, 
	231, 234, 237, 231, 231, 232, 232, 232, 
	231, 230, 40, 227, 227, 227, 227, 227, 
	227, 227, 227, 227, 227, 227, 227, 227, 
	227, 227, 227, 227, 227, 227, 227, 227, 
	227, 227, 227, 227, 227, 227, 227, 227, 
	227, 238, 228, 228, 228, 228, 228, 228, 
	228, 228, 228, 228, 228, 228, 228, 228, 
	228, 228, 238, 229, 229, 229, 229, 229, 
	238, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 238, 230, 
	238, 231, 231, 231, 231, 123, 231, 231, 
	231, 123, 123, 123, 123, 231, 123, 123, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	123, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 123, 123, 123, 123, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 123, 123, 123, 231, 
	123, 231, 231, 231, 231, 238, 231, 231, 
	231, 238, 238, 238, 238, 231, 238, 238, 
	231, 239, 239, 239, 239, 239, 239, 239, 
	239, 239, 239, 231, 231, 231, 231, 231, 
	238, 231, 239, 239, 239, 239, 239, 239, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 238, 238, 238, 238, 
	231, 231, 239, 239, 239, 239, 239, 239, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 238, 238, 238, 231, 
	238, 231, 231, 231, 231, 240, 231, 231, 
	231, 240, 240, 240, 240, 231, 241, 240, 
	231, 242, 242, 242, 242, 242, 242, 242, 
	242, 242, 242, 231, 231, 231, 231, 231, 
	240, 231, 242, 242, 242, 242, 242, 242, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 240, 240, 240, 240, 
	231, 231, 242, 242, 242, 242, 242, 242, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 240, 240, 240, 231, 
	240, 244, 244, 244, 244, 244, 244, 244, 
	244, 244, 244, 243, 243, 243, 243, 243, 
	243, 243, 244, 244, 244, 244, 244, 244, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 244, 244, 244, 244, 244, 244, 
	243, 231, 231, 231, 231, 240, 231, 231, 
	231, 240, 240, 240, 240, 231, 241, 240, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	240, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 240, 240, 240, 240, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 231, 231, 231, 231, 
	231, 231, 231, 231, 240, 240, 240, 231, 
	240, 246, 245, 245, 245, 246, 246, 246, 
	246, 245, 245, 246, 245, 247, 248, 248, 
	248, 248, 248, 248, 248, 249, 249, 245, 
	245, 245, 245, 245, 246, 245, 40, 40, 
	250, 40, 245, 245, 40, 40, 245, 245, 
	245, 245, 251, 245, 245, 252, 245, 245, 
	40, 245, 245, 245, 40, 245, 245, 40, 
	246, 246, 246, 246, 245, 245, 253, 253, 
	134, 40, 253, 253, 40, 40, 245, 245, 
	40, 245, 245, 253, 245, 252, 245, 253, 
	253, 253, 254, 253, 40, 255, 245, 40, 
	246, 246, 246, 245, 257, 257, 257, 257, 
	257, 257, 257, 257, 256, 259, 259, 259, 
	259, 259, 259, 259, 259, 258, 262, 261, 
	265, 265, 265, 265, 265, 265, 265, 265, 
	265, 265, 264, 264, 264, 264, 264, 264, 
	264, 265, 265, 265, 265, 265, 265, 264, 
	264, 264, 264, 264, 264, 264, 264, 264, 
	264, 264, 264, 264, 264, 264, 264, 264, 
	264, 264, 264, 264, 264, 264, 264, 264, 
	264, 265, 265, 265, 265, 265, 265, 264, 
	266, 267, 266, 268, 266, 269, 266, 270, 
	266, 271, 266, 272, 266, 273, 266, 156, 
	274, 274, 274, 274, 274, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 274, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 156, 267, 275, 275, 
	275, 275, 275, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 275, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 156, 268, 276, 276, 276, 276, 
	276, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 276, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	156, 269, 277, 277, 277, 277, 277, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 277, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 156, 270, 
	278, 278, 278, 278, 278, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 278, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 156, 271, 279, 279, 
	279, 279, 279, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 279, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 156, 272, 280, 280, 280, 280, 
	280, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 280, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	156, 273, 281, 281, 281, 281, 281, 156, 
	156, 156, 156, 156, 156, 156, 156, 156, 
	156, 156, 156, 156, 156, 156, 156, 156, 
	156, 281, 156, 158, 158, 158, 158, 158, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 158, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 266, 266, 266, 156, 
	266, 283, 283, 283, 283, 283, 283, 283, 
	283, 283, 283, 267, 267, 267, 267, 267, 
	267, 267, 283, 283, 283, 283, 283, 283, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 283, 283, 283, 283, 283, 283, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 284, 267, 
	285, 285, 285, 285, 285, 285, 285, 285, 
	285, 285, 268, 268, 268, 268, 268, 268, 
	268, 285, 285, 285, 285, 285, 285, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 285, 285, 285, 285, 285, 285, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 268, 268, 268, 
	268, 268, 268, 268, 268, 284, 268, 286, 
	286, 286, 286, 286, 286, 286, 286, 286, 
	286, 269, 269, 269, 269, 269, 269, 269, 
	286, 286, 286, 286, 286, 286, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	286, 286, 286, 286, 286, 286, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 269, 269, 269, 269, 
	269, 269, 269, 269, 284, 269, 287, 287, 
	287, 287, 287, 287, 287, 287, 287, 287, 
	270, 270, 270, 270, 270, 270, 270, 287, 
	287, 287, 287, 287, 287, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 287, 
	287, 287, 287, 287, 287, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 270, 270, 270, 270, 270, 
	270, 270, 270, 284, 270, 288, 288, 288, 
	288, 288, 288, 288, 288, 288, 288, 271, 
	271, 271, 271, 271, 271, 271, 288, 288, 
	288, 288, 288, 288, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 288, 288, 
	288, 288, 288, 288, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 271, 271, 271, 271, 271, 271, 
	271, 271, 284, 271, 289, 289, 289, 289, 
	289, 289, 289, 289, 289, 289, 272, 272, 
	272, 272, 272, 272, 272, 289, 289, 289, 
	289, 289, 289, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 289, 289, 289, 
	289, 289, 289, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 284, 272, 290, 290, 290, 290, 290, 
	290, 290, 290, 290, 290, 273, 273, 273, 
	273, 273, 273, 273, 290, 290, 290, 290, 
	290, 290, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 290, 290, 290, 290, 
	290, 290, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	284, 273, 284, 156, 292, 291, 291, 291, 
	291, 291, 293, 291, 291, 291, 294, 294, 
	294, 294, 294, 294, 294, 294, 294, 291, 
	291, 295, 291, 161, 296, 296, 296, 296, 
	296, 296, 296, 296, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 296, 296, 
	296, 296, 296, 296, 296, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 296, 
	296, 296, 296, 162, 296, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 296, 
	163, 163, 163, 163, 163, 163, 163, 163, 
	163, 296, 160, 296, 296, 296, 296, 296, 
	296, 163, 163, 163, 163, 163, 163, 163, 
	163, 163, 163, 296, 164, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 296, 296, 
	296, 296, 161, 296, 296, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 296, 
	296, 296, 296, 164, 296, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 164, 
	164, 164, 164, 164, 164, 164, 164, 296, 
	0
]

class << self
	attr_accessor :_re_scanner_trans_targs
	private :_re_scanner_trans_targs, :_re_scanner_trans_targs=
end
self._re_scanner_trans_targs = [
	139, 140, 3, 141, 5, 6, 142, 139, 
	7, 139, 139, 139, 9, 11, 139, 139, 
	139, 12, 10, 139, 13, 139, 15, 21, 
	139, 16, 18, 20, 17, 19, 22, 24, 
	26, 23, 25, 0, 28, 27, 153, 30, 
	0, 31, 32, 47, 154, 33, 34, 35, 
	36, 39, 41, 43, 45, 37, 38, 40, 
	42, 44, 46, 155, 157, 159, 49, 52, 
	161, 51, 155, 155, 155, 56, 57, 155, 
	59, 60, 71, 75, 79, 83, 87, 91, 
	96, 100, 102, 105, 61, 68, 62, 66, 
	63, 64, 65, 155, 67, 69, 70, 72, 
	73, 74, 76, 77, 78, 80, 81, 82, 
	84, 85, 86, 88, 89, 90, 92, 94, 
	93, 95, 97, 98, 99, 101, 103, 104, 
	107, 108, 155, 167, 168, 111, 169, 113, 
	114, 170, 167, 116, 117, 175, 177, 180, 
	177, 177, 121, 177, 123, 126, 124, 125, 
	177, 127, 128, 129, 130, 131, 177, 181, 
	133, 182, 190, 199, 177, 177, 134, 207, 
	207, 135, 136, 137, 138, 1, 2, 4, 
	143, 144, 145, 146, 147, 139, 148, 139, 
	149, 150, 139, 151, 139, 152, 139, 139, 
	139, 139, 139, 8, 139, 139, 139, 139, 
	139, 139, 139, 139, 139, 139, 14, 139, 
	139, 29, 155, 156, 158, 160, 162, 155, 
	163, 164, 165, 166, 155, 155, 155, 155, 
	48, 50, 53, 155, 155, 54, 155, 155, 
	55, 58, 106, 109, 110, 112, 171, 172, 
	167, 172, 167, 167, 167, 173, 167, 174, 
	167, 115, 176, 167, 167, 177, 177, 178, 
	178, 177, 118, 119, 177, 177, 122, 132, 
	177, 179, 177, 177, 177, 177, 120, 177, 
	177, 177, 177, 183, 184, 185, 186, 187, 
	188, 189, 191, 192, 193, 194, 195, 196, 
	197, 198, 177, 200, 177, 201, 202, 203, 
	204, 205, 206, 207, 208, 209, 210, 211, 
	207
]

class << self
	attr_accessor :_re_scanner_trans_actions
	private :_re_scanner_trans_actions, :_re_scanner_trans_actions=
end
self._re_scanner_trans_actions = [
	1, 2, 0, 2, 0, 0, 2, 3, 
	0, 4, 5, 6, 7, 0, 8, 9, 
	10, 0, 7, 11, 0, 12, 0, 0, 
	13, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 14, 0, 0, 0, 0, 
	0, 0, 0, 0, 16, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 17, 18, 18, 0, 0, 
	18, 0, 19, 20, 21, 0, 0, 22, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 23, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 24, 25, 26, 0, 26, 0, 
	0, 26, 27, 0, 0, 0, 28, 18, 
	29, 30, 0, 31, 0, 0, 0, 0, 
	32, 0, 0, 0, 0, 0, 33, 0, 
	0, 0, 0, 0, 34, 35, 0, 36, 
	37, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 18, 40, 41, 42, 
	0, 0, 43, 0, 44, 18, 45, 46, 
	47, 48, 49, 50, 51, 52, 53, 54, 
	55, 56, 57, 58, 59, 60, 0, 61, 
	62, 0, 64, 0, 18, 18, 0, 65, 
	0, 0, 18, 18, 66, 67, 68, 69, 
	0, 0, 0, 70, 71, 0, 72, 73, 
	0, 0, 0, 0, 0, 0, 0, 26, 
	74, 75, 76, 77, 78, 0, 79, 18, 
	80, 0, 18, 81, 82, 83, 84, 85, 
	86, 87, 0, 0, 88, 89, 0, 0, 
	90, 0, 91, 92, 93, 94, 0, 95, 
	96, 97, 98, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 18, 99, 0, 100, 0, 0, 0, 
	0, 0, 0, 101, 18, 18, 18, 18, 
	102
]

class << self
	attr_accessor :_re_scanner_to_state_actions
	private :_re_scanner_to_state_actions, :_re_scanner_to_state_actions=
end
self._re_scanner_to_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 38, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 63, 63, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 38, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 63, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 63, 
	0, 0, 0, 0
]

class << self
	attr_accessor :_re_scanner_from_state_actions
	private :_re_scanner_from_state_actions, :_re_scanner_from_state_actions=
end
self._re_scanner_from_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 39, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 39, 39, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 39, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 39, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 39, 
	0, 0, 0, 0
]

class << self
	attr_accessor :_re_scanner_eof_actions
	private :_re_scanner_eof_actions, :_re_scanner_eof_actions=
end
self._re_scanner_eof_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 14, 14, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 14, 14, 
	0, 0, 14, 14, 14, 14, 14, 14, 
	14, 14, 14, 14, 14, 14, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 14, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 14, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0
]

class << self
	attr_accessor :_re_scanner_eof_trans
	private :_re_scanner_eof_trans, :_re_scanner_eof_trans=
end
self._re_scanner_eof_trans = [
	0, 1, 1, 1, 1, 1, 1, 8, 
	11, 11, 11, 11, 11, 11, 22, 22, 
	22, 22, 22, 22, 22, 22, 22, 22, 
	22, 22, 22, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	60, 60, 60, 60, 60, 60, 60, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 124, 124, 124, 
	124, 124, 124, 131, 131, 131, 0, 0, 
	137, 137, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 158, 160, 
	160, 160, 160, 0, 185, 185, 185, 185, 
	186, 186, 185, 185, 187, 189, 191, 193, 
	195, 200, 0, 0, 216, 216, 216, 216, 
	216, 216, 216, 216, 216, 216, 223, 0, 
	239, 239, 239, 239, 124, 239, 241, 244, 
	241, 0, 257, 259, 261, 264, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 267, 
	267, 267, 267, 267, 267, 267, 267, 283, 
	283, 283, 283, 283, 283, 283, 283, 0, 
	297, 297, 297, 297
]

class << self
	attr_accessor :re_scanner_start
end
self.re_scanner_start = 139;
class << self
	attr_accessor :re_scanner_first_final
end
self.re_scanner_first_final = 139;
class << self
	attr_accessor :re_scanner_error
end
self.re_scanner_error = 0;

class << self
	attr_accessor :re_scanner_en_unicode_property
end
self.re_scanner_en_unicode_property = 154;
class << self
	attr_accessor :re_scanner_en_character_set
end
self.re_scanner_en_character_set = 155;
class << self
	attr_accessor :re_scanner_en_set_escape_sequence
end
self.re_scanner_en_set_escape_sequence = 167;
class << self
	attr_accessor :re_scanner_en_escape_sequence
end
self.re_scanner_en_escape_sequence = 177;
class << self
	attr_accessor :re_scanner_en_conditional_expression
end
self.re_scanner_en_conditional_expression = 207;
class << self
	attr_accessor :re_scanner_en_main
end
self.re_scanner_en_main = 139;


# line 776 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"

  # General scanner error (catch all)
  class ScannerError < StandardError; end

  # Base for all scanner validation errors
  class ValidationError < StandardError
    def initialize(reason)
      super reason
    end
  end

  # Unexpected end of pattern
  class PrematureEndError < ScannerError
    def initialize(where = '')
      super "Premature end of pattern at #{where}"
    end
  end

  # Invalid sequence format. Used for escape sequences, mainly.
  class InvalidSequenceError < ValidationError
    def initialize(what = 'sequence', where = '')
      super "Invalid #{what} at #{where}"
    end
  end

  # Invalid group. Used for named groups.
  class InvalidGroupError < ValidationError
    def initialize(what, reason)
      super "Invalid #{what}, #{reason}."
    end
  end

  # Invalid groupOption. Used for inline options.
  class InvalidGroupOption < ValidationError
    def initialize(option, text)
      super "Invalid group option #{option} in #{text}"
    end
  end

  # Invalid back reference. Used for name a number refs/calls.
  class InvalidBackrefError < ValidationError
    def initialize(what, reason)
      super "Invalid back reference #{what}, #{reason}"
    end
  end

  # The property name was not recognized by the scanner.
  class UnknownUnicodePropertyError < ValidationError
    def initialize(name)
      super "Unknown unicode character property name #{name}"
    end
  end

  # Scans the given regular expression text, or Regexp object and collects the
  # emitted token into an array that gets returned at the end. If a block is
  # given, it gets called for each emitted token.
  #
  # This method may raise errors if a syntax error is encountered.
  # --------------------------------------------------------------------------
  def self.scan(input_object, &block)
    top, stack = 0, []

    if input_object.is_a?(Regexp)
      input    = input_object.source
      @free_spacing  = (input_object.options & Regexp::EXTENDED != 0)
    else
      input   = input_object
      @free_spacing = false
    end


    data  = input.unpack("c*") if input.is_a?(String)
    eof   = data.length

    @tokens = []
    @block  = block_given? ? block : nil

    @in_group, @group_depth = false, 0
    @in_options, @spacing_stack = false, [[@free_spacing, 0]]

    in_set,   set_depth, set_type   = false, 0, :set
    in_conditional, conditional_depth, conditional_stack = false, 0, []

    
# line 1634 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner.rb"
begin
	p ||= 0
	pe ||= data.length
	cs = re_scanner_start
	top = 0
	ts = nil
	te = nil
	act = 0
end

# line 860 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
    
# line 1647 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner.rb"
begin
	testEof = false
	_slen, _trans, _keys, _inds, _acts, _nacts = nil
	_goto_level = 0
	_resume = 10
	_eof_trans = 15
	_again = 20
	_test_eof = 30
	_out = 40
	while true
	if _goto_level <= 0
	if p == pe
		_goto_level = _test_eof
		next
	end
	if cs == 0
		_goto_level = _out
		next
	end
	end
	if _goto_level <= _resume
	case _re_scanner_from_state_actions[cs] 
	when 39 then
# line 1 "NONE"
		begin
ts = p
		end
# line 1675 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner.rb"
	end
	_keys = cs << 1
	_inds = _re_scanner_index_offsets[cs]
	_slen = _re_scanner_key_spans[cs]
	_wide = data[p].ord
	_trans = if (   _slen > 0 && 
			_re_scanner_trans_keys[_keys] <= _wide && 
			_wide <= _re_scanner_trans_keys[_keys + 1] 
		    ) then
			_re_scanner_indicies[ _inds + _wide - _re_scanner_trans_keys[_keys] ] 
		 else 
			_re_scanner_indicies[ _inds + _slen ]
		 end
	end
	if _goto_level <= _eof_trans
	cs = _re_scanner_trans_targs[_trans]
	if _re_scanner_trans_actions[_trans] != 0
	case _re_scanner_trans_actions[_trans]
	when 14 then
# line 133 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
	when 7 then
# line 146 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 @group_depth -= 1; @in_group = @group_depth > 0 ? true : false 		end
	when 18 then
# line 1 "NONE"
		begin
te = p+1
		end
	when 16 then
# line 61 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/property.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te, 1).first
      if in_set
        type = :set
      else
        type = text[1,1] == 'p' ? :property : :nonproperty
      end

      name = data[ts+2..te-2].pack('c*').gsub(/[\s_]/,'').downcase
      if name[0].chr == '^'
        name = name[1..-1]
        type = :nonproperty
      end

      case name
      # Named
      when 'alnum'
        self.emit(type, :alnum,       text, ts-1, te)
      when 'alpha'
        self.emit(type, :alpha,       text, ts-1, te)
      when 'ascii'
        self.emit(type, :ascii,       text, ts-1, te)
      when 'blank'
        self.emit(type, :blank,       text, ts-1, te)
      when 'cntrl'
        self.emit(type, :cntrl,       text, ts-1, te)
      when 'digit'
        self.emit(type, :digit,       text, ts-1, te)
      when 'graph'
        self.emit(type, :graph,       text, ts-1, te)
      when 'lower'
        self.emit(type, :lower,       text, ts-1, te)
      when 'print'
        self.emit(type, :print,       text, ts-1, te)
      when 'punct'
        self.emit(type, :punct,       text, ts-1, te)
      when 'space'
        self.emit(type, :space,       text, ts-1, te)
      when 'upper'
        self.emit(type, :upper,       text, ts-1, te)
      when 'xdigit'
        self.emit(type, :xdigit,      text, ts-1, te)

      when 'any'
        self.emit(type, :any,         text, ts-1, te)
      when 'assigned'
        self.emit(type, :assigned,    text, ts-1, te)
      when 'newline'
        self.emit(type, :newline,     text, ts-1, te)
      when 'word'
        self.emit(type, :word,        text, ts-1, te)

      # Letters
      when 'l', 'letter'
        self.emit(type, :letter_any,       text, ts-1, te)
      when 'lu', 'uppercaseletter'
        self.emit(type, :letter_uppercase, text, ts-1, te)
      when 'll', 'lowercaseletter'
        self.emit(type, :letter_lowercase, text, ts-1, te)
      when 'lt', 'titlecaseletter'
        self.emit(type, :letter_titlecase, text, ts-1, te)
      when 'lm', 'modifierletter'
        self.emit(type, :letter_modifier,  text, ts-1, te)
      when 'lo', 'otherletter'
        self.emit(type, :letter_other,     text, ts-1, te)

      # Marks
      when 'm', 'mark'
        self.emit(type, :mark_any,         text, ts-1, te)
      when 'mn', 'nonspacingmark'
        self.emit(type, :mark_nonspacing,  text, ts-1, te)
      when 'mc', 'spacingmark'
        self.emit(type, :mark_spacing,     text, ts-1, te)
      when 'me', 'enclosingmark'
        self.emit(type, :mark_enclosing,   text, ts-1, te)

      # Numbers
      when 'n', 'number'
        self.emit(type, :number_any,       text, ts-1, te)
      when 'nd', 'decimalnumber'
        self.emit(type, :number_decimal,   text, ts-1, te)
      when 'nl', 'letternumber'
        self.emit(type, :number_letter,    text, ts-1, te)
      when 'no', 'othernumber'
        self.emit(type, :number_other,     text, ts-1, te)

      # Punctuation
      when 'p', 'punctuation'
        self.emit(type, :punct_any,        text, ts-1, te)
      when 'pc', 'connectorpunctuation'
        self.emit(type, :punct_connector,  text, ts-1, te)
      when 'pd', 'dashpunctuation'
        self.emit(type, :punct_dash,       text, ts-1, te)
      when 'ps', 'openpunctuation'
        self.emit(type, :punct_open,       text, ts-1, te)
      when 'pe', 'closepunctuation'
        self.emit(type, :punct_close,      text, ts-1, te)
      when 'pi', 'initialpunctuation'
        self.emit(type, :punct_initial,    text, ts-1, te)
      when 'pf', 'finalpunctuation'
        self.emit(type, :punct_final,      text, ts-1, te)
      when 'po', 'otherpunctuation'
        self.emit(type, :punct_other,      text, ts-1, te)

      # Symbols
      when 's', 'symbol'
        self.emit(type, :symbol_any,       text, ts-1, te)
      when 'sm', 'mathsymbol'
        self.emit(type, :symbol_math,      text, ts-1, te)
      when 'sc', 'currencysymbol'
        self.emit(type, :symbol_currency,  text, ts-1, te)
      when 'sk', 'modifiersymbol'
        self.emit(type, :symbol_modifier,  text, ts-1, te)
      when 'so', 'othersymbol'
        self.emit(type, :symbol_other,     text, ts-1, te)

      # Separators
      when 'z', 'separator'
        self.emit(type, :separator_any,    text, ts-1, te)
      when 'zs', 'spaceseparator'
        self.emit(type, :separator_space,  text, ts-1, te)
      when 'zl', 'lineseparator'
        self.emit(type, :separator_line,   text, ts-1, te)
      when 'zp', 'paragraphseparator'
        self.emit(type, :separator_para,   text, ts-1, te)

      # Codepoints
      when 'c', 'other'
        self.emit(type, :other,         text, ts-1, te)
      when 'cc', 'control'
        self.emit(type, :control,       text, ts-1, te)
      when 'cf', 'format'
        self.emit(type, :format,        text, ts-1, te)
      when 'cs', 'surrogate'
        self.emit(type, :surrogate,     text, ts-1, te)
      when 'co', 'privateuse'
        self.emit(type, :private_use,   text, ts-1, te)
      when 'cn', 'unassigned'
        self.emit(type, :unassigned,    text, ts-1, te)

      # Age
      when 'age=1.1'
        self.emit(type, :age_1_1,     text, ts-1, te)
      when 'age=2.0'
        self.emit(type, :age_2_0,     text, ts-1, te)
      when 'age=2.1'
        self.emit(type, :age_2_1,     text, ts-1, te)
      when 'age=3.0'
        self.emit(type, :age_3_0,     text, ts-1, te)
      when 'age=3.1'
        self.emit(type, :age_3_1,     text, ts-1, te)
      when 'age=3.2'
        self.emit(type, :age_3_2,     text, ts-1, te)
      when 'age=4.0'
        self.emit(type, :age_4_0,     text, ts-1, te)
      when 'age=4.1'
        self.emit(type, :age_4_1,     text, ts-1, te)
      when 'age=5.0'
        self.emit(type, :age_5_0,     text, ts-1, te)
      when 'age=5.1'
        self.emit(type, :age_5_1,     text, ts-1, te)
      when 'age=5.2'
        self.emit(type, :age_5_2,     text, ts-1, te)
      when 'age=6.0'
        self.emit(type, :age_6_0,     text, ts-1, te)
      when 'age=6.1'
        self.emit(type, :age_6_1,     text, ts-1, te)
      when 'age=6.2'
        self.emit(type, :age_6_2,     text, ts-1, te)
      when 'age=6.3'
        self.emit(type, :age_6_3,     text, ts-1, te)
      when 'age=7.0'
        self.emit(type, :age_7_0,     text, ts-1, te)

      # Derived Properties
      when 'ahex', 'asciihexdigit'
        self.emit(type, :ascii_hex,                       text, ts-1, te)
      when 'alphabetic'
        self.emit(type, :alphabetic,                      text, ts-1, te)
      when 'cased'
        self.emit(type, :cased,                           text, ts-1, te)
      when 'cwcf', 'changeswhencasefolded'
        self.emit(type, :changes_when_casefolded,         text, ts-1, te)
      when 'cwcm', 'changeswhencasemapped'
        self.emit(type, :changes_when_casemapped,         text, ts-1, te)
      when 'cwl', 'changeswhenlowercased'
        self.emit(type, :changes_when_lowercased,         text, ts-1, te)
      when 'cwt', 'changeswhentitlecased'
        self.emit(type, :changes_when_titlecased,         text, ts-1, te)
      when 'cwu', 'changeswhenuppercased'
        self.emit(type, :changes_when_uppercased,         text, ts-1, te)
      when 'ci', 'caseignorable'
        self.emit(type, :case_ignorable,                  text, ts-1, te)
      when 'bidic', 'bidicontrol'
        self.emit(type, :bidi_control,                    text, ts-1, te)
      when 'dash'
        self.emit(type, :dash,                            text, ts-1, te)
      when 'dep', 'deprecated'
        self.emit(type, :deprecated,                      text, ts-1, te)
      when 'di', 'defaultignorablecodepoint'
        self.emit(type, :default_ignorable_cp,            text, ts-1, te)
      when 'dia', 'diacritic'
        self.emit(type, :diacritic,                       text, ts-1, te)
      when 'ext', 'extender'
        self.emit(type, :extender,                        text, ts-1, te)
      when 'grbase', 'graphemebase'
        self.emit(type, :grapheme_base,                   text, ts-1, te)
      when 'grext', 'graphemeextend'
        self.emit(type, :grapheme_extend,                 text, ts-1, te)
      when 'grlink', 'graphemelink' # NOTE: deprecated as of Unicode 5.0
        self.emit(type, :grapheme_link,                   text, ts-1, te)
      when 'hex', 'hexdigit'
        self.emit(type, :hex_digit,                       text, ts-1, te)
      when 'hyphen' # NOTE: deprecated as of Unicode 6.0
        self.emit(type, :hyphen,                          text, ts-1, te)
      when 'idc', 'idcontinue'
        self.emit(type, :id_continue,                     text, ts-1, te)
      when 'ideo', 'ideographic'
        self.emit(type, :ideographic,                     text, ts-1, te)
      when 'ids', 'idstart'
        self.emit(type, :id_start,                        text, ts-1, te)
      when 'idsb', 'idsbinaryoperator'
        self.emit(type, :ids_binary_op,                   text, ts-1, te)
      when 'idst', 'idstrinaryoperator'
        self.emit(type, :ids_trinary_op,                  text, ts-1, te)
      when 'joinc', 'joincontrol'
        self.emit(type, :join_control,                    text, ts-1, te)
      when 'loe', 'logicalorderexception'
        self.emit(type, :logical_order_exception,         text, ts-1, te)
      when 'lowercase'
        self.emit(type, :lowercase,                       text, ts-1, te)
      when 'math'
        self.emit(type, :math,                            text, ts-1, te)
      when 'nchar', 'noncharactercodepoint'
        self.emit(type, :non_character_cp,                text, ts-1, te)
      when 'oalpha', 'otheralphabetic'
        self.emit(type, :other_alphabetic,                text, ts-1, te)
      when 'odi', 'otherdefaultignorablecodepoint'
        self.emit(type, :other_default_ignorable_cp,      text, ts-1, te)
      when 'ogrext', 'othergraphemeextend'
        self.emit(type, :other_grapheme_extended,         text, ts-1, te)
      when 'oidc', 'otheridcontinue'
        self.emit(type, :other_id_continue,               text, ts-1, te)
      when 'oids', 'otheridstart'
        self.emit(type, :other_id_start,                  text, ts-1, te)
      when 'olower', 'otherlowercase'
        self.emit(type, :other_lowercase,                 text, ts-1, te)
      when 'omath', 'othermath'
        self.emit(type, :other_math,                      text, ts-1, te)
      when 'oupper', 'otheruppercase'
        self.emit(type, :other_uppercase,                 text, ts-1, te)
      when 'patsyn', 'patternsyntax'
        self.emit(type, :pattern_syntax,                  text, ts-1, te)
      when 'patws', 'patternwhitespace'
        self.emit(type, :pattern_whitespace,              text, ts-1, te)
      when 'qmark', 'quotationmark'
        self.emit(type, :quotation_mark,                  text, ts-1, te)
      when 'radical'
        self.emit(type, :radical,                         text, ts-1, te)
      when 'sd', 'softdotted'
        self.emit(type, :soft_dotted,                     text, ts-1, te)
      when 'sterm'
        self.emit(type, :sentence_terminal,               text, ts-1, te)
      when 'term', 'terminalpunctuation'
        self.emit(type, :terminal_punctuation,            text, ts-1, te)
      when 'uideo', 'unifiedideograph'
        self.emit(type, :unified_ideograph,               text, ts-1, te)
      when 'uppercase'
        self.emit(type, :uppercase,                       text, ts-1, te)
      when 'vs', 'variationselector'
        self.emit(type, :variation_selector,              text, ts-1, te)
      when 'wspace', 'whitespace'
        self.emit(type, :whitespace,                      text, ts-1, te)
      when 'xids', 'xidstart'
        self.emit(type, :xid_start,                       text, ts-1, te)
      when 'xidc', 'xidcontinue'
        self.emit(type, :xid_continue,                    text, ts-1, te)

      # Scripts
      when 'aghb', 'caucasianalbanian'
        self.emit(type, :script_caucasian_albanian,       text, ts-1, te)
      when 'arab', 'arabic'
        self.emit(type, :script_arabic,                   text, ts-1, te)
      when 'armi', 'imperialaramaic'
        self.emit(type, :script_imperial_aramaic,         text, ts-1, te)
      when 'armn', 'armenian'
        self.emit(type, :script_armenian,                 text, ts-1, te)
      when 'avst', 'avestan'
        self.emit(type, :script_avestan,                  text, ts-1, te)
      when 'bali', 'balinese'
        self.emit(type, :script_balinese,                 text, ts-1, te)
      when 'bamu', 'bamum'
        self.emit(type, :script_bamum,                    text, ts-1, te)
      when 'bass', 'bassavah'
        self.emit(type, :script_bassa_vah,                text, ts-1, te)
      when 'batk', 'batak'
        self.emit(type, :script_batak,                    text, ts-1, te)
      when 'beng', 'bengali'
        self.emit(type, :script_bengali,                  text, ts-1, te)
      when 'bopo', 'bopomofo'
        self.emit(type, :script_bopomofo,                 text, ts-1, te)
      when 'brah', 'brahmi'
        self.emit(type, :script_brahmi,                   text, ts-1, te)
      when 'brai', 'braille'
        self.emit(type, :script_braille,                  text, ts-1, te)
      when 'bugi', 'buginese'
        self.emit(type, :script_buginese,                 text, ts-1, te)
      when 'buhd', 'buhid'
        self.emit(type, :script_buhid,                    text, ts-1, te)
      when 'cans', 'canadianaboriginal'
        self.emit(type, :script_canadian_aboriginal,      text, ts-1, te)
      when 'cari', 'carian'
        self.emit(type, :script_carian,                   text, ts-1, te)
      when 'cham'
        self.emit(type, :script_cham,                     text, ts-1, te)
      when 'cher', 'cherokee'
        self.emit(type, :script_cherokee,                 text, ts-1, te)
      when 'copt', 'coptic', 'qaac'
        self.emit(type, :script_coptic,                   text, ts-1, te)
      when 'cprt', 'cypriot'
        self.emit(type, :script_cypriot,                  text, ts-1, te)
      when 'cyrl', 'cyrillic'
        self.emit(type, :script_cyrillic,                 text, ts-1, te)
      when 'deva', 'devanagari'
        self.emit(type, :script_devanagari,               text, ts-1, te)
      when 'dsrt', 'deseret'
        self.emit(type, :script_deseret,                  text, ts-1, te)
      when 'dupl', 'duployan'
        self.emit(type, :script_duployan,                 text, ts-1, te)
      when 'egyp', 'egyptianhieroglyphs'
        self.emit(type, :script_egyptian_hieroglyphs,     text, ts-1, te)
      when 'elba', 'elbasan'
        self.emit(type, :script_elbasan,                  text, ts-1, te)
      when 'ethi', 'ethiopic'
        self.emit(type, :script_ethiopic,                 text, ts-1, te)
      when 'geor', 'georgian'
        self.emit(type, :script_georgian,                 text, ts-1, te)
      when 'glag', 'glagolitic'
        self.emit(type, :script_glagolitic,               text, ts-1, te)
      when 'goth', 'gothic'
        self.emit(type, :script_gothic,                   text, ts-1, te)
      when 'gran', 'grantha'
        self.emit(type, :script_grantha,                  text, ts-1, te)
      when 'grek', 'greek'
        self.emit(type, :script_greek,                    text, ts-1, te)
      when 'gujr', 'gujarati'
        self.emit(type, :script_gujarati,                 text, ts-1, te)
      when 'guru', 'gurmukhi'
        self.emit(type, :script_gurmukhi,                 text, ts-1, te)
      when 'hang', 'hangul'
        self.emit(type, :script_hangul,                   text, ts-1, te)
      when 'hani', 'han'
        self.emit(type, :script_han,                      text, ts-1, te)
      when 'hano', 'hanunoo'
        self.emit(type, :script_hanunoo,                  text, ts-1, te)
      when 'hebr', 'hebrew'
        self.emit(type, :script_hebrew,                   text, ts-1, te)
      when 'hira', 'hiragana'
        self.emit(type, :script_hiragana,                 text, ts-1, te)
      when 'hmng', 'pahawhhmong'
        self.emit(type, :script_pahawh_hmong,             text, ts-1, te)
      when 'hrkt', 'katakanaorhiragana'
        self.emit(type, :script_katakana_or_hiragana,     text, ts-1, te)
      when 'ital', 'olditalic'
        self.emit(type, :script_old_italic,               text, ts-1, te)
      when 'java', 'javanese'
        self.emit(type, :script_javanese,                 text, ts-1, te)
      when 'kali', 'kayahli'
        self.emit(type, :script_kayah_li,                 text, ts-1, te)
      when 'kana', 'katakana'
        self.emit(type, :script_katakana,                 text, ts-1, te)
      when 'khar', 'kharoshthi'
        self.emit(type, :script_kharoshthi,               text, ts-1, te)
      when 'khmr', 'khmer'
        self.emit(type, :script_khmer,                    text, ts-1, te)
      when 'khoj', 'khojki'
        self.emit(type, :script_khojki,                   text, ts-1, te)
      when 'knda', 'kannada'
        self.emit(type, :script_kannada,                  text, ts-1, te)
      when 'kthi', 'kaithi'
        self.emit(type, :script_kaithi,                   text, ts-1, te)
      when 'lana', 'taitham'
        self.emit(type, :script_tai_tham,                 text, ts-1, te)
      when 'laoo', 'lao'
        self.emit(type, :script_lao,                      text, ts-1, te)
      when 'latn', 'latin'
        self.emit(type, :script_latin,                    text, ts-1, te)
      when 'lepc', 'lepcha'
        self.emit(type, :script_lepcha,                   text, ts-1, te)
      when 'limb', 'limbu'
        self.emit(type, :script_limbu,                    text, ts-1, te)
      when 'lina', 'lineara'
        self.emit(type, :script_linear_a,                 text, ts-1, te)
      when 'linb', 'linearb'
        self.emit(type, :script_linear_b,                 text, ts-1, te)
      when 'lisu'
        self.emit(type, :script_lisu,                     text, ts-1, te)
      when 'lyci', 'lycian'
        self.emit(type, :script_lycian,                   text, ts-1, te)
      when 'lydi', 'lydian'
        self.emit(type, :script_lydian,                   text, ts-1, te)
      when 'mlym', 'malayalam'
        self.emit(type, :script_malayalam,                text, ts-1, te)
      when 'mahj', 'mahajani'
        self.emit(type, :script_mahajani,                 text, ts-1, te)
      when 'mand', 'mandaic'
        self.emit(type, :script_mandaic,                  text, ts-1, te)
      when 'mani', 'manichaean'
        self.emit(type, :script_manichaean,               text, ts-1, te)
      when 'mend', 'mendekikakui'
        self.emit(type, :script_mende_kikakui,            text, ts-1, te)
      when 'modi'
        self.emit(type, :script_modi,                     text, ts-1, te)
      when 'mong', 'mongolian'
        self.emit(type, :script_mongolian,                text, ts-1, te)
      when 'mroo', 'mro'
        self.emit(type, :script_mro,                      text, ts-1, te)
      when 'mtei', 'meeteimayek'
        self.emit(type, :script_meetei_mayek,             text, ts-1, te)
      when 'mymr', 'myanmar'
        self.emit(type, :script_myanmar,                  text, ts-1, te)
      when 'narb', 'oldnortharabian'
        self.emit(type, :script_old_north_arabian,        text, ts-1, te)
      when 'nbat', 'nabataean'
        self.emit(type, :script_nabataean,                text, ts-1, te)
      when 'nkoo', 'nko'
        self.emit(type, :script_nko,                      text, ts-1, te)
      when 'ogam', 'ogham'
        self.emit(type, :script_ogham,                    text, ts-1, te)
      when 'olck', 'olchiki'
        self.emit(type, :script_ol_chiki,                 text, ts-1, te)
      when 'orkh', 'oldturkic'
        self.emit(type, :script_old_turkic,               text, ts-1, te)
      when 'orya', 'oriya'
        self.emit(type, :script_oriya,                    text, ts-1, te)
      when 'osma', 'osmanya'
        self.emit(type, :script_osmanya,                  text, ts-1, te)
      when 'palm', 'palmyrene'
        self.emit(type, :script_palmyrene,                text, ts-1, te)
      when 'pauc', 'paucinhau'
        self.emit(type, :script_pau_cin_hau,              text, ts-1, te)
      when 'perm', 'oldpermic'
        self.emit(type, :script_old_permic,               text, ts-1, te)
      when 'phag', 'phagspa'
        self.emit(type, :script_phags_pa,                 text, ts-1, te)
      when 'phli', 'inscriptionalpahlavi'
        self.emit(type, :script_inscriptional_pahlavi,    text, ts-1, te)
      when 'phlp', 'psalterpahlavi'
        self.emit(type, :script_psalter_pahlavi,          text, ts-1, te)
      when 'phnx', 'phoenician'
        self.emit(type, :script_phoenician,               text, ts-1, te)
      when 'prti', 'inscriptionalparthian'
        self.emit(type, :script_inscriptional_parthian,   text, ts-1, te)
      when 'rjng', 'rejang'
        self.emit(type, :script_rejang,                   text, ts-1, te)
      when 'runr', 'runic'
        self.emit(type, :script_runic,                    text, ts-1, te)
      when 'samr', 'samaritan'
        self.emit(type, :script_samaritan,                text, ts-1, te)
      when 'sarb', 'oldsoutharabian'
        self.emit(type, :script_old_south_arabian,        text, ts-1, te)
      when 'saur', 'saurashtra'
        self.emit(type, :script_saurashtra,               text, ts-1, te)
      when 'shaw', 'shavian'
        self.emit(type, :script_shavian,                  text, ts-1, te)
      when 'sidd', 'siddham'
        self.emit(type, :script_siddham,                  text, ts-1, te)
      when 'sind', 'khudawadi'
        self.emit(type, :script_khudawadi,                text, ts-1, te)
      when 'sinh', 'sinhala'
        self.emit(type, :script_sinhala,                  text, ts-1, te)
      when 'sund', 'sundanese'
        self.emit(type, :script_sundanese,                text, ts-1, te)
      when 'sylo', 'sylotinagri'
        self.emit(type, :script_syloti_nagri,             text, ts-1, te)
      when 'syrc', 'syriac'
        self.emit(type, :script_syriac,                   text, ts-1, te)
      when 'tagb', 'tagbanwa'
        self.emit(type, :script_tagbanwa,                 text, ts-1, te)
      when 'tale', 'taile'
        self.emit(type, :script_tai_le,                   text, ts-1, te)
      when 'talu', 'newtailue'
        self.emit(type, :script_new_tai_lue,              text, ts-1, te)
      when 'taml', 'tamil'
        self.emit(type, :script_tamil,                    text, ts-1, te)
      when 'tavt', 'taiviet'
        self.emit(type, :script_tai_viet,                 text, ts-1, te)
      when 'telu', 'telugu'
        self.emit(type, :script_telugu,                   text, ts-1, te)
      when 'tfng', 'tifinagh'
        self.emit(type, :script_tifinagh,                 text, ts-1, te)
      when 'tglg', 'tagalog'
        self.emit(type, :script_tagalog,                  text, ts-1, te)
      when 'thaa', 'thaana'
        self.emit(type, :script_thaana,                   text, ts-1, te)
      when 'thai'
        self.emit(type, :script_thai,                     text, ts-1, te)
      when 'tibt', 'tibetan'
        self.emit(type, :script_tibetan,                  text, ts-1, te)
      when 'tirh', 'tirhuta'
        self.emit(type, :script_tirhuta,                  text, ts-1, te)
      when 'ugar', 'ugaritic'
        self.emit(type, :script_ugaritic,                 text, ts-1, te)
      when 'vaii', 'vai'
        self.emit(type, :script_vai,                      text, ts-1, te)
      when 'wara', 'warangciti'
        self.emit(type, :script_warang_citi,              text, ts-1, te)
      when 'xpeo', 'oldpersian'
        self.emit(type, :script_old_persian,              text, ts-1, te)
      when 'xsux', 'cuneiform'
        self.emit(type, :script_cuneiform,                text, ts-1, te)
      when 'yiii', 'yi'
        self.emit(type, :script_yi,                       text, ts-1, te)
      when 'zinh', 'inherited', 'qaai'
        self.emit(type, :script_inherited,                text, ts-1, te)
      when 'zyyy', 'common'
        self.emit(type, :script_common,                   text, ts-1, te)
      when 'zzzz', 'unknown'
        self.emit(type, :script_unknown,                  text, ts-1, te)

      # Unicode blocks
      when 'inalphabeticpresentationforms'
        self.emit(type, :block_inalphabetic_presentation_forms,           text, ts-1, te)
      when 'inalphabeticpresentationforms'
        self.emit(type, :block_inalphabetic_presentation_forms,           text, ts-1, te)
      when 'inarabicpresentationforms-a'
        self.emit(type, :block_inarabic_presentation_forms_a,             text, ts-1, te)
      when 'inarabicpresentationforms-b'
        self.emit(type, :block_inarabic_presentation_forms_b,             text, ts-1, te)
      when 'inarabic'
        self.emit(type, :block_inarabic,                                  text, ts-1, te)
      when 'inarmenian'
        self.emit(type, :block_inarmenian,                                text, ts-1, te)
      when 'inarrows'
        self.emit(type, :block_inarrows,                                  text, ts-1, te)
      when 'inbasiclatin'
        self.emit(type, :block_inbasic_latin,                             text, ts-1, te)
      when 'inbengali'
        self.emit(type, :block_inbengali,                                 text, ts-1, te)
      when 'inblockelements'
        self.emit(type, :block_inblock_elements,                          text, ts-1, te)
      when 'inbopomofoextended'
        self.emit(type, :block_inbopomofo_extended,                       text, ts-1, te)
      when 'inbopomofo'
        self.emit(type, :block_inbopomofo,                                text, ts-1, te)
      when 'inboxdrawing'
        self.emit(type, :block_inbox_drawing,                             text, ts-1, te)
      when 'inbraillepatterns'
        self.emit(type, :block_inbraille_patterns,                        text, ts-1, te)
      when 'inbuhid'
        self.emit(type, :block_inbuhid,                                   text, ts-1, te)
      when 'incjkcompatibilityforms'
        self.emit(type, :block_incjk_compatibility_forms,                 text, ts-1, te)
      when 'incjkcompatibilityideographs'
        self.emit(type, :block_incjk_compatibility_ideographs,            text, ts-1, te)
      when 'incjkcompatibility'
        self.emit(type, :block_incjk_compatibility,                       text, ts-1, te)
      when 'incjkradicalssupplement'
        self.emit(type, :block_incjk_radicals_supplement,                 text, ts-1, te)
      when 'incjksymbolsandpunctuation'
        self.emit(type, :block_incjk_symbols_and_punctuation,             text, ts-1, te)
      when 'incjkunifiedideographsextensiona'
        self.emit(type, :block_incjk_unified_ideographs_extension_a,      text, ts-1, te)
      when 'incjkunifiedideographs'
        self.emit(type, :block_incjk_unified_ideographs,                  text, ts-1, te)
      when 'incherokee'
        self.emit(type, :block_incherokee,                                text, ts-1, te)
      when 'incombiningdiacriticalmarksforsymbols'
        self.emit(type, :block_incombining_diacritical_marks_for_symbols, text, ts-1, te)
      when 'incombiningdiacriticalmarks'
        self.emit(type, :block_incombining_diacritical_marks,             text, ts-1, te)
      when 'incombininghalfmarks'
        self.emit(type, :block_incombining_half_marks,                    text, ts-1, te)
      when 'incontrolpictures'
        self.emit(type, :block_incontrol_pictures,                        text, ts-1, te)
      when 'incurrencysymbols'
        self.emit(type, :block_incurrency_symbols,                        text, ts-1, te)
      when 'incyrillicsupplementary'
        self.emit(type, :block_incyrillic_supplementary,                  text, ts-1, te)
      when 'incyrillic'
        self.emit(type, :block_incyrillic,                                text, ts-1, te)
      when 'indevanagari'
        self.emit(type, :block_indevanagari,                              text, ts-1, te)
      when 'indingbats'
        self.emit(type, :block_indingbats,                                text, ts-1, te)
      when 'inenclosedalphanumerics'
        self.emit(type, :block_inenclosed_alphanumerics,                  text, ts-1, te)
      when 'inenclosedcjklettersandmonths'
        self.emit(type, :block_inenclosed_cjk_letters_and_months,         text, ts-1, te)
      when 'inethiopic'
        self.emit(type, :block_inethiopic,                                text, ts-1, te)
      when 'ingeneralpunctuation'
        self.emit(type, :block_ingeneral_punctuation,                     text, ts-1, te)
      when 'ingeometricshapes'
        self.emit(type, :block_ingeometric_shapes,                        text, ts-1, te)
      when 'ingeorgian'
        self.emit(type, :block_ingeorgian,                                text, ts-1, te)
      when 'ingreekextended'
        self.emit(type, :block_ingreek_extended,                          text, ts-1, te)
      when 'ingreekandcoptic'
        self.emit(type, :block_ingreek_and_coptic,                        text, ts-1, te)
      when 'ingujarati'
        self.emit(type, :block_ingujarati,                                text, ts-1, te)
      when 'ingurmukhi'
        self.emit(type, :block_ingurmukhi,                                text, ts-1, te)
      when 'inhalfwidthandfullwidthforms'
        self.emit(type, :block_inhalfwidth_and_fullwidth_forms,           text, ts-1, te)
      when 'inhangulcompatibilityjamo'
        self.emit(type, :block_inhangul_compatibility_jamo,               text, ts-1, te)
      when 'inhanguljamo'
        self.emit(type, :block_inhangul_jamo,                             text, ts-1, te)
      when 'inhangulsyllables'
        self.emit(type, :block_inhangul_syllables,                        text, ts-1, te)
      when 'inhanunoo'
        self.emit(type, :block_inhanunoo,                                 text, ts-1, te)
      when 'inhebrew'
        self.emit(type, :block_inhebrew,                                  text, ts-1, te)
      when 'inhighprivateusesurrogates'
        self.emit(type, :block_inhigh_private_use_surrogates,             text, ts-1, te)
      when 'inhighsurrogates'
        self.emit(type, :block_inhigh_surrogates,                         text, ts-1, te)
      when 'inhiragana'
        self.emit(type, :block_inhiragana,                                text, ts-1, te)
      when 'inipaextensions'
        self.emit(type, :block_inipa_extensions,                          text, ts-1, te)
      when 'inideographicdescriptioncharacters'
        self.emit(type, :block_inideographic_description_characters,      text, ts-1, te)
      when 'inkanbun'
        self.emit(type, :block_inkanbun,                                  text, ts-1, te)
      when 'inkangxiradicals'
        self.emit(type, :block_inkangxi_radicals,                         text, ts-1, te)
      when 'inkannada'
        self.emit(type, :block_inkannada,                                 text, ts-1, te)
      when 'inkatakanaphoneticextensions'
        self.emit(type, :block_inkatakana_phonetic_extensions,            text, ts-1, te)
      when 'inkatakana'
        self.emit(type, :block_inkatakana,                                text, ts-1, te)
      when 'inkhmersymbols'
        self.emit(type, :block_inkhmer_symbols,                           text, ts-1, te)
      when 'inkhmer'
        self.emit(type, :block_inkhmer,                                   text, ts-1, te)
      when 'inlao'
        self.emit(type, :block_inlao,                                     text, ts-1, te)
      when 'inlatin-1supplement'
        self.emit(type, :block_inlatin_1_supplement,                      text, ts-1, te)
      when 'inlatinextended-a'
        self.emit(type, :block_inlatin_extended_a,                        text, ts-1, te)
      when 'inlatinextended-b'
        self.emit(type, :block_inlatin_extended_b,                        text, ts-1, te)
      when 'inlatinextendedadditional'
        self.emit(type, :block_inlatin_extended_additional,               text, ts-1, te)
      when 'inletterlikesymbols'
        self.emit(type, :block_inletterlike_symbols,                      text, ts-1, te)
      when 'inlimbu'
        self.emit(type, :block_inlimbu,                                   text, ts-1, te)
      when 'inlowsurrogates'
        self.emit(type, :block_inlow_surrogates,                          text, ts-1, te)
      when 'inmalayalam'
        self.emit(type, :block_inmalayalam,                               text, ts-1, te)
      when 'inmathematicaloperators'
        self.emit(type, :block_inmathematical_operators,                  text, ts-1, te)
      when 'inmiscellaneousmathematicalsymbols-a'
        self.emit(type, :block_inmiscellaneous_mathematical_symbols_a,    text, ts-1, te)
      when 'inmiscellaneousmathematicalsymbols-b'
        self.emit(type, :block_inmiscellaneous_mathematical_symbols_b,    text, ts-1, te)
      when 'inmiscellaneoussymbolsandarrows'
        self.emit(type, :block_inmiscellaneous_symbols_and_arrows,        text, ts-1, te)
      when 'inmiscellaneoussymbols'
        self.emit(type, :block_inmiscellaneous_symbols,                   text, ts-1, te)
      when 'inmiscellaneoustechnical'
        self.emit(type, :block_inmiscellaneous_technical,                 text, ts-1, te)
      when 'inmongolian'
        self.emit(type, :block_inmongolian,                               text, ts-1, te)
      when 'inmyanmar'
        self.emit(type, :block_inmyanmar,                                 text, ts-1, te)
      when 'innumberforms'
        self.emit(type, :block_innumber_forms,                            text, ts-1, te)
      when 'inogham'
        self.emit(type, :block_inogham,                                   text, ts-1, te)
      when 'inopticalcharacterrecognition'
        self.emit(type, :block_inoptical_character_recognition,           text, ts-1, te)
      when 'inoriya'
        self.emit(type, :block_inoriya,                                   text, ts-1, te)
      when 'inphoneticextensions'
        self.emit(type, :block_inphonetic_extensions,                     text, ts-1, te)
      when 'inprivateusearea'
        self.emit(type, :block_inprivate_use_area,                        text, ts-1, te)
      when 'inrunic'
        self.emit(type, :block_inrunic,                                   text, ts-1, te)
      when 'insinhala'
        self.emit(type, :block_insinhala,                                 text, ts-1, te)
      when 'insmallformvariants'
        self.emit(type, :block_insmall_form_variants,                     text, ts-1, te)
      when 'inspacingmodifierletters'
        self.emit(type, :block_inspacing_modifier_letters,                text, ts-1, te)
      when 'inspecials'
        self.emit(type, :block_inspecials,                                text, ts-1, te)
      when 'insuperscriptsandsubscripts'
        self.emit(type, :block_insuperscripts_and_subscripts,             text, ts-1, te)
      when 'insupplementalarrows-a'
        self.emit(type, :block_insupplemental_arrows_a,                   text, ts-1, te)
      when 'insupplementalarrows-b'
        self.emit(type, :block_insupplemental_arrows_b,                   text, ts-1, te)
      when 'insupplementalmathematicaloperators'
        self.emit(type, :block_insupplemental_mathematical_operators,     text, ts-1, te)
      when 'insyriac'
        self.emit(type, :block_insyriac,                                  text, ts-1, te)
      when 'intagalog'
        self.emit(type, :block_intagalog,                                 text, ts-1, te)
      when 'intagbanwa'
        self.emit(type, :block_intagbanwa,                                text, ts-1, te)
      when 'intaile'
        self.emit(type, :block_intai_le,                                  text, ts-1, te)
      when 'intamil'
        self.emit(type, :block_intamil,                                   text, ts-1, te)
      when 'intelugu'
        self.emit(type, :block_intelugu,                                  text, ts-1, te)
      when 'inthaana'
        self.emit(type, :block_inthaana,                                  text, ts-1, te)
      when 'inthai'
        self.emit(type, :block_inthai,                                    text, ts-1, te)
      when 'intibetan'
        self.emit(type, :block_intibetan,                                 text, ts-1, te)
      when 'inunifiedcanadianaboriginalsyllabics'
        self.emit(type, :block_inunified_canadian_aboriginal_syllabics,   text, ts-1, te)
      when 'invariationselectors'
        self.emit(type, :block_invariation_selectors,                     text, ts-1, te)
      when 'inyiradicals'
        self.emit(type, :block_inyi_radicals,                             text, ts-1, te)
      when 'inyisyllables'
        self.emit(type, :block_inyi_syllables,                            text, ts-1, te)
      when 'inyijinghexagramsymbols'
        self.emit(type, :block_inyijing_hexagram_symbols,                 text, ts-1, te)

      else
        # Should this really be an error? Or would emitting
        # an :unknown for the property be better?
        #
        # self.emit(type, :unknown, text, ts-1, te)

        raise UnknownUnicodePropertyError.new(name)
      end

      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 67 then
# line 152 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      set_type  = set_depth > 1 ? :subset : :set
      set_depth -= 1; in_set = set_depth > 0 ? true : false

      emit(set_type, :close, *text(data, ts, te))

      if set_depth == 0
        	begin
		cs = 139
		_goto_level = _again
		next
	end

      else
        	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

      end
     end
		end
	when 71 then
# line 165 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin  # special case, emits two tokens
      set_type  = set_depth > 1 ? :subset : :set
      set_depth -= 1; in_set = set_depth > 0 ? true : false

      emit(set_type, :member, copy(data, ts..te-2), ts, te)
      emit(set_type, :close,  copy(data, ts+1..te-1), ts, te)

      if set_depth == 0
        	begin
		cs = 139
		_goto_level = _again
		next
	end

      else
        	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

      end
     end
		end
	when 68 then
# line 179 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te).first
      if @tokens.last[1] == :open
        emit(set_type, :negate, text, ts, te)
      else
        emit(set_type, :member, text, ts, te)
      end
     end
		end
	when 19 then
# line 188 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :range, *text(data, ts, te))
     end
		end
	when 70 then
# line 192 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :intersection, *text(data, ts, te))
     end
		end
	when 66 then
# line 196 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      	begin
		stack[top] = cs
		top+= 1
		cs = 167
		_goto_level = _again
		next
	end

     end
		end
	when 23 then
# line 208 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te).first

      class_name = text[2..-3]
      if class_name[0].chr == '^'
        class_name = "non#{class_name[1..-1]}"
      end

      token_sym = "class_#{class_name}".to_sym
      emit(set_type, token_sym, text, ts, te)
     end
		end
	when 22 then
# line 220 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :collation, *text(data, ts, te))
     end
		end
	when 24 then
# line 224 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :equivalent, *text(data, ts, te))
     end
		end
	when 65 then
# line 230 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :member, *text(data, ts, te))
     end
		end
	when 64 then
# line 238 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :member, *text(data, ts, te))
     end
		end
	when 73 then
# line 200 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 155
		_goto_level = _again
		next
	end

     end
		end
	when 69 then
# line 238 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(set_type, :member, *text(data, ts, te))
     end
		end
	when 21 then
# line 200 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 155
		_goto_level = _again
		next
	end

     end
		end
	when 17 then
# line 238 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      emit(set_type, :member, *text(data, ts, te))
     end
		end
	when 78 then
# line 246 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :backspace, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 76 then
# line 251 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te, 1).first
      when '\d'; emit(set_type, :type_digit,     text, ts-1, te)
      when '\D'; emit(set_type, :type_nondigit,  text, ts-1, te)
      when '\h'; emit(set_type, :type_hex,       text, ts-1, te)
      when '\H'; emit(set_type, :type_nonhex,    text, ts-1, te)
      when '\s'; emit(set_type, :type_space,     text, ts-1, te)
      when '\S'; emit(set_type, :type_nonspace,  text, ts-1, te)
      when '\w'; emit(set_type, :type_word,      text, ts-1, te)
      when '\W'; emit(set_type, :type_nonword,   text, ts-1, te)
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 82 then
# line 265 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :range_hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 74 then
# line 275 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :escape, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 77 then
# line 280 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      p = p - 1;
      cs = 155;
      	begin
		stack[top] = cs
		top+= 1
		cs = 154
		_goto_level = _again
		next
	end

      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 81 then
# line 265 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(set_type, :range_hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 80 then
# line 270 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(set_type, :member_hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 79 then
# line 292 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(set_type, :escape, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 27 then
# line 270 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      emit(set_type, :member_hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 25 then
# line 1 "NONE"
		begin
	case act
	when 0 then
	begin	begin
		cs = 0
		_goto_level = _again
		next
	end
end
	when 18 then
	begin begin p = ((te))-1; end

      emit(set_type, :escape, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

    end
	when 20 then
	begin begin p = ((te))-1; end

      emit(set_type, :escape, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

    end
end 
			end
	when 87 then
# line 302 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te, 1).first
      emit(:backref, :number, text, ts-1, te)
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 92 then
# line 308 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:escape, :octal, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 84 then
# line 313 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te, 1).first
      when '\.';  emit(:escape, :dot,               text, ts-1, te)
      when '\|';  emit(:escape, :alternation,       text, ts-1, te)
      when '\^';  emit(:escape, :bol,               text, ts-1, te)
      when '\$';  emit(:escape, :eol,               text, ts-1, te)
      when '\?';  emit(:escape, :zero_or_one,       text, ts-1, te)
      when '\*';  emit(:escape, :zero_or_more,      text, ts-1, te)
      when '\+';  emit(:escape, :one_or_more,       text, ts-1, te)
      when '\(';  emit(:escape, :group_open,        text, ts-1, te)
      when '\)';  emit(:escape, :group_close,       text, ts-1, te)
      when '\{';  emit(:escape, :interval_open,     text, ts-1, te)
      when '\}';  emit(:escape, :interval_close,    text, ts-1, te)
      when '\[';  emit(:escape, :set_open,          text, ts-1, te)
      when '\]';  emit(:escape, :set_close,         text, ts-1, te)
      when "\\\\";
        emit(:escape, :backslash, text, ts-1, te)
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 89 then
# line 334 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      # \b is emitted as backspace only when inside a character set, otherwise
      # it is a word boundary anchor. A syntax might "normalize" it if needed.
      case text = text(data, ts, te, 1).first
      when '\a'; emit(:escape, :bell,           text, ts-1, te)
      when '\e'; emit(:escape, :escape,         text, ts-1, te)
      when '\f'; emit(:escape, :form_feed,      text, ts-1, te)
      when '\n'; emit(:escape, :newline,        text, ts-1, te)
      when '\r'; emit(:escape, :carriage,       text, ts-1, te)
      when '\s'; emit(:escape, :space,          text, ts-1, te)
      when '\t'; emit(:escape, :tab,            text, ts-1, te)
      when '\v'; emit(:escape, :vertical_tab,   text, ts-1, te)
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 32 then
# line 350 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te, 1).first
      if text[2].chr == '{'
        emit(:escape, :codepoint_list, text, ts-1, te)
      else
        emit(:escape, :codepoint,      text, ts-1, te)
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 97 then
# line 360 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:escape, :hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 100 then
# line 365 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:escape, :hex_wide, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 34 then
# line 374 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      raise InvalidSequenceError.new("wide hex sequence")
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 28 then
# line 379 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :control, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("control sequence")
        end
      else
        raise PrematureEndError.new("control sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 31 then
# line 394 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 88 then
# line 409 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      p = p - 1;
      cs = 139;
      	begin
		stack[top] = cs
		top+= 1
		cs = 154
		_goto_level = _again
		next
	end
 	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 83 then
# line 415 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:escape, :literal, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 91 then
# line 308 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(:escape, :octal, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 96 then
# line 360 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(:escape, :hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 98 then
# line 374 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      raise InvalidSequenceError.new("wide hex sequence")
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 94 then
# line 394 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 35 then
# line 374 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      raise InvalidSequenceError.new("wide hex sequence")
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 30 then
# line 394 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 90 then
# line 1 "NONE"
		begin
	case act
	when 21 then
	begin begin p = ((te))-1; end

      text = text(data, ts, te, 1).first
      emit(:backref, :number, text, ts-1, te)
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

    end
	when 22 then
	begin begin p = ((te))-1; end

      emit(:escape, :octal, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

    end
end 
			end
	when 37 then
# line 425 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te-1).first
      emit(:conditional, :condition, text, ts, te-1)
      emit(:conditional, :condition_close, ')', te-1, te)
     end
		end
	when 101 then
# line 431 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      p = p - 1;
      	begin
		stack[top] = cs
		top+= 1
		cs = 139
		_goto_level = _again
		next
	end

     end
		end
	when 102 then
# line 431 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      p = p - 1;
      	begin
		stack[top] = cs
		top+= 1
		cs = 139
		_goto_level = _again
		next
	end

     end
		end
	when 36 then
# line 431 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      p = p - 1;
      	begin
		stack[top] = cs
		top+= 1
		cs = 139
		_goto_level = _again
		next
	end

     end
		end
	when 43 then
# line 444 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:meta, :dot, *text(data, ts, te))
     end
		end
	when 46 then
# line 448 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if in_conditional and conditional_stack.length > 0 and 
         conditional_stack.last[1] == @group_depth
        emit(:conditional, :separator, *text(data, ts, te))
      else
        emit(:meta, :alternation, *text(data, ts, te))
      end
     end
		end
	when 45 then
# line 459 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:anchor, :bol, *text(data, ts, te))
     end
		end
	when 40 then
# line 463 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:anchor, :eol, *text(data, ts, te))
     end
		end
	when 60 then
# line 467 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:keep, :mark, *text(data, ts, te))
     end
		end
	when 58 then
# line 471 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '\\A'; emit(:anchor, :bos,                text, ts, te)
      when '\\z'; emit(:anchor, :eos,                text, ts, te)
      when '\\Z'; emit(:anchor, :eos_ob_eol,         text, ts, te)
      when '\\b'; emit(:anchor, :word_boundary,      text, ts, te)
      when '\\B'; emit(:anchor, :nonword_boundary,   text, ts, te)
      when '\\G'; emit(:anchor, :match_start,        text, ts, te)
      else
        raise ScannerError.new(
          "Unexpected character in anchor at #{text} (char #{ts})")
      end
     end
		end
	when 59 then
# line 491 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '\\d'; emit(:type, :digit,      text, ts, te)
      when '\\D'; emit(:type, :nondigit,   text, ts, te)
      when '\\h'; emit(:type, :hex,        text, ts, te)
      when '\\H'; emit(:type, :nonhex,     text, ts, te)
      when '\\s'; emit(:type, :space,      text, ts, te)
      when '\\S'; emit(:type, :nonspace,   text, ts, te)
      when '\\w'; emit(:type, :word,       text, ts, te)
      when '\\W'; emit(:type, :nonword,    text, ts, te)
      else
        raise ScannerError.new(
          "Unexpected character in type at #{text} (char #{ts})")
      end
     end
		end
	when 44 then
# line 510 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 155
		_goto_level = _again
		next
	end

     end
		end
	when 8 then
# line 522 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te).first

      in_conditional = true unless in_conditional
      conditional_depth += 1
      conditional_stack << [conditional_depth, @group_depth]

      emit(:conditional, :open, text[0..-2], ts, te-1)
      emit(:conditional, :condition_open, '(', te-1, te)
      	begin
		stack[top] = cs
		top+= 1
		cs = 207
		_goto_level = _again
		next
	end

     end
		end
	when 9 then
# line 555 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      p = scan_options(p, data, ts, te)
     end
		end
	when 6 then
# line 565 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '(?=';  emit(:assertion, :lookahead,    text, ts, te)
      when '(?!';  emit(:assertion, :nlookahead,   text, ts, te)
      when '(?<='; emit(:assertion, :lookbehind,   text, ts, te)
      when '(?<!'; emit(:assertion, :nlookbehind,  text, ts, te)
      end
     end
		end
	when 10 then
# line 581 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '(?:';  emit(:group, :passive,      text, ts, te)
      when '(?>';  emit(:group, :atomic,       text, ts, te)

      when /^\(\?<(\w*)>/
        empty_name_error(:group, 'named group (ab)') if $1.empty?

        emit(:group, :named_ab,  text, ts, te)

      when /^\(\?'(\w*)'/
        empty_name_error(:group, 'named group (sq)') if $1.empty?

        emit(:group, :named_sq,  text, ts, te)

      else
        raise ScannerError.new(
          "Unknown subexpression group format '#{text}'")
      end
     end
		end
	when 13 then
# line 636 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when /^\\([gk])<>/ # angle brackets
        empty_backref_error("ref/call (ab)")

      when /^\\([gk])''/ # single quotes
        empty_backref_error("ref/call (sq)")

      when /^\\([gk])<[^\d-](\w+)?>/ # angle-brackets
        if $1 == 'k'
          emit(:backref, :name_ref_ab,  text, ts, te)
        else
          emit(:backref, :name_call_ab,  text, ts, te)
        end

      when /^\\([gk])'[^\d-](\w+)?'/ #single quotes
        if $1 == 'k'
          emit(:backref, :name_ref_sq,  text, ts, te)
        else
          emit(:backref, :name_call_sq,  text, ts, te)
        end

      when /^\\([gk])<\d+>/ # angle-brackets
        if $1 == 'k'
          emit(:backref, :number_ref_ab,  text, ts, te)
        else
          emit(:backref, :number_call_ab,  text, ts, te)
        end

      when /^\\([gk])'\d+'/ # single quotes
        if $1 == 'k'
          emit(:backref, :number_ref_sq,  text, ts, te)
        else
          emit(:backref, :number_call_sq,  text, ts, te)
        end

      when /^\\([gk])<-\d+>/ # angle-brackets
        if $1 == 'k'
          emit(:backref, :number_rel_ref_ab,  text, ts, te)
        else
          emit(:backref, :number_rel_call_ab,  text, ts, te)
        end

      when /^\\([gk])'-\d+'/ # single quotes
        if $1 == 'k'
          emit(:backref, :number_rel_ref_sq,  text, ts, te)
        else
          emit(:backref, :number_rel_call_sq,  text, ts, te)
        end

      when /^\\k<[^\d-](\w+)?[+\-]\d+>/ # angle-brackets
        emit(:backref, :name_nest_ref_ab,  text, ts, te)

      when /^\\k'[^\d-](\w+)?[+\-]\d+'/ # single-quotes
        emit(:backref, :name_nest_ref_sq,  text, ts, te)

      when /^\\([gk])<\d+[+\-]\d+>/ # angle-brackets
        emit(:backref, :number_nest_ref_ab,  text, ts, te)

      when /^\\([gk])'\d+[+\-]\d+'/ # single-quotes
        emit(:backref, :number_nest_ref_sq,  text, ts, te)

      else
        raise ScannerError.new(
          "Unknown backreference format '#{text}'")
      end
     end
		end
	when 56 then
# line 707 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '?' ;  emit(:quantifier, :zero_or_one,            text, ts, te)
      when '??';  emit(:quantifier, :zero_or_one_reluctant,  text, ts, te)
      when '?+';  emit(:quantifier, :zero_or_one_possessive, text, ts, te)
      end
     end
		end
	when 52 then
# line 715 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '*' ;  emit(:quantifier, :zero_or_more,            text, ts, te)
      when '*?';  emit(:quantifier, :zero_or_more_reluctant,  text, ts, te)
      when '*+';  emit(:quantifier, :zero_or_more_possessive, text, ts, te)
      end
     end
		end
	when 54 then
# line 723 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '+' ;  emit(:quantifier, :one_or_more,            text, ts, te)
      when '+?';  emit(:quantifier, :one_or_more_reluctant,  text, ts, te)
      when '++';  emit(:quantifier, :one_or_more_possessive, text, ts, te)
      end
     end
		end
	when 62 then
# line 731 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:quantifier, :interval, *text(data, ts, te))
     end
		end
	when 4 then
# line 741 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if @free_spacing
        emit(:free_space, :comment, *text(data, ts, te))
      else
        append_literal(data, ts, te)
      end
     end
		end
	when 49 then
# line 602 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      text = text(data, ts, te).first
      emit(:group, :capture, text, ts, te)
     end
		end
	when 55 then
# line 707 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      case text = text(data, ts, te).first
      when '?' ;  emit(:quantifier, :zero_or_one,            text, ts, te)
      when '??';  emit(:quantifier, :zero_or_one_reluctant,  text, ts, te)
      when '?+';  emit(:quantifier, :zero_or_one_possessive, text, ts, te)
      end
     end
		end
	when 51 then
# line 715 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      case text = text(data, ts, te).first
      when '*' ;  emit(:quantifier, :zero_or_more,            text, ts, te)
      when '*?';  emit(:quantifier, :zero_or_more_reluctant,  text, ts, te)
      when '*+';  emit(:quantifier, :zero_or_more_possessive, text, ts, te)
      end
     end
		end
	when 53 then
# line 723 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      case text = text(data, ts, te).first
      when '+' ;  emit(:quantifier, :one_or_more,            text, ts, te)
      when '+?';  emit(:quantifier, :one_or_more_reluctant,  text, ts, te)
      when '++';  emit(:quantifier, :one_or_more_possessive, text, ts, te)
      end
     end
		end
	when 61 then
# line 731 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(:quantifier, :interval, *text(data, ts, te))
     end
		end
	when 57 then
# line 737 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      	begin
		stack[top] = cs
		top+= 1
		cs = 177
		_goto_level = _again
		next
	end

     end
		end
	when 48 then
# line 749 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      if @free_spacing
        emit(:free_space, :whitespace, *text(data, ts, te))
      else
        append_literal(data, ts, te)
      end
     end
		end
	when 47 then
# line 764 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      append_literal(data, ts, te)
     end
		end
	when 5 then
# line 602 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      text = text(data, ts, te).first
      emit(:group, :capture, text, ts, te)
     end
		end
	when 12 then
# line 737 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      	begin
		stack[top] = cs
		top+= 1
		cs = 177
		_goto_level = _again
		next
	end

     end
		end
	when 3 then
# line 764 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      append_literal(data, ts, te)
     end
		end
	when 1 then
# line 1 "NONE"
		begin
	case act
	when 0 then
	begin	begin
		cs = 0
		_goto_level = _again
		next
	end
end
	when 59 then
	begin begin p = ((te))-1; end

      append_literal(data, ts, te)
    end
end 
			end
	when 72 then
# line 133 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 200 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 155
		_goto_level = _again
		next
	end

     end
		end
	when 20 then
# line 133 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 200 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 155
		_goto_level = _again
		next
	end

     end
		end
	when 95 then
# line 133 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 360 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(:escape, :hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 99 then
# line 133 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 374 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      raise InvalidSequenceError.new("wide hex sequence")
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 93 then
# line 133 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 394 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 29 then
# line 133 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 394 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 33 then
# line 139 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise InvalidSequenceError.new('sequence', text)
  		end
# line 370 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 50 then
# line 146 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 @group_depth -= 1; @in_group = @group_depth > 0 ? true : false 		end
# line 145 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 @group_depth += 1; @in_group = true 		end
	when 11 then
# line 146 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 @group_depth -= 1; @in_group = @group_depth > 0 ? true : false 		end
# line 540 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:group, :comment, *text(data, ts, te))
     end
		end
	when 42 then
# line 146 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 @group_depth -= 1; @in_group = @group_depth > 0 ? true : false 		end
# line 607 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if in_conditional and conditional_stack.last and
         conditional_stack.last[1] == (@group_depth + 1)

        emit(:conditional, :close, *text(data, ts, te))
        conditional_stack.pop

        if conditional_stack.length == 0
          in_conditional = false
        end
      else
        if @spacing_stack.length > 1 and
          @spacing_stack.last[1] == (@group_depth + 1)
          @spacing_stack.pop

          @free_spacing = @spacing_stack.last[0]

          if @spacing_stack.length == 1
            @in_options = false
          end
        end

        emit(:group, :close, *text(data, ts, te))
      end
     end
		end
	when 41 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 145 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 @group_depth += 1; @in_group = true 		end
	when 75 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 275 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 18;		end
	when 26 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 292 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 20;		end
	when 86 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 302 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 21;		end
	when 85 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 308 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 22;		end
	when 2 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 764 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 59;		end
# line 4009 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner.rb"
	end
	end
	end
	if _goto_level <= _again
	case _re_scanner_to_state_actions[cs] 
	when 63 then
# line 1 "NONE"
		begin
ts = nil;		end
	when 38 then
# line 1 "NONE"
		begin
ts = nil;		end
# line 1 "NONE"
		begin
act = 0
		end
# line 4027 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner.rb"
	end

	if cs == 0
		_goto_level = _out
		next
	end
	p += 1
	if p != pe
		_goto_level = _resume
		next
	end
	end
	if _goto_level <= _test_eof
	if p == eof
	if _re_scanner_eof_trans[cs] > 0
		_trans = _re_scanner_eof_trans[cs] - 1;
		_goto_level = _eof_trans
		next;
	end
	  case _re_scanner_eof_actions[cs]
	when 15 then
# line 53 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/property.rl"
		begin

    raise PrematureEndError.new('unicode property')
  		end
	when 14 then
# line 133 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 4061 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner.rb"
	  end
	end

	end
	if _goto_level <= _out
		break
	end
end
	end

# line 861 "/Users/ammar/src/code/ruby/projects/regexp_parser/lib/regexp_parser/scanner/scanner.rl"

    if cs == re_scanner_error
      text = ts ? copy(data, ts-1..-1) : data.pack('c*')
      raise ScannerError.new("Scan error at '#{text}'")
    end

    raise PrematureEndError.new("(missing group closing paranthesis) "+
          "[#{@in_group}:#{@group_depth}]") if @in_group
    raise PrematureEndError.new("(missing set closing bracket) "+
          "[#{in_set}:#{set_depth}]") if in_set

    # when the entire expression is a literal run
    emit_literal if @literal

    @tokens
  end

  private

  # Ragel's regex-based scan of the group options introduced a lot of
  # ambiguity, so we just ask it to find the beginning of what looks
  # like an options run and handle the rest in here.
  def self.scan_options(p, data, ts, te)
    text = text(data, ts, te).first

    options_char, options_length = true, 0

    # Copy while we have option characters. There is no maximum length,
    # as ruby allows things like '(?xxxxxxxxx-xxxxxxxxxxxxx:abc)'.
    negative_options = false
    while options_char
      if data[te + options_length]
        c = data[te + options_length].chr

        if c =~ /[-mixdau]/
          negative_options = true if c == '-'

          raise InvalidGroupOption.new(c, text) if negative_options and
            c =~ /[dau]/

          text << c ; p += 1 ; options_length += 1
        else
          options_char = false
        end
      else
        raise PrematureEndError.new("expression options `#{text}'")
      end
    end

    if data[te + options_length]
      c = data[te + options_length].chr

      if c == ':'
        # Include the ':' in the options text
        text << c ; p += 1 ; options_length += 1
        emit_options(text, ts, te + options_length)

      elsif c == ')'
        # Don't include the closing ')', let group_close handle it.
        emit_options(text, ts, te + options_length)

      else
        # Plain Regexp reports this as 'undefined group option'
        raise ScannerError.new(
          "Unexpected `#{c}' in options sequence, ':' or ')' expected")
      end
    else
      raise PrematureEndError.new("expression options `#{text}'")
    end

    p # return the new value of the data pointer
  end

  # Copy from ts to te from data as text
  def self.copy(data, range)
    data[range].pack('c*')
  end

  # Copy from ts to te from data as text, returning an array with the text
  #  and the offsets used to copy it.
  def self.text(data, ts, te, soff = 0)
    [copy(data, ts-soff..te-1), ts-soff, te]
  end

  # Appends one or more characters to the literal buffer, to be emitted later
  # by a call to emit_literal. Contents can be a mix of ASCII and UTF-8.
  def self.append_literal(data, ts, te)
    @literal ||= []
    @literal << text(data, ts, te)
  end

  # Emits the literal run collected by calls to the append_literal method,
  # using the total start (ts) and end (te) offsets of the run.
  def self.emit_literal
    ts, te = @literal.first[1], @literal.last[2]
    text = @literal.map {|t| t[0]}.join

    text.force_encoding('utf-8') if text.respond_to?(:force_encoding)

    @literal = nil
    emit(:literal, :literal, text, ts, te)
  end

  def self.emit_options(text, ts, te)
    if text =~ /\(\?([mixdau]+)?-?([mix]+)?:/
      positive, negative = $1, $2

      if positive =~ /x/
        @free_spacing = true
      end

      # If the x appears in both, treat it like ruby does, the second cancels
      # the first.
      if negative =~ /x/
        @free_spacing = false
      end
    end

    @in_options = true
    @spacing_stack << [@free_spacing, @group_depth]

    emit(:group, :options, text, ts, te)
  end

  # Emits an array with the details of the scanned pattern
  def self.emit(type, token, text, ts, te)
    #puts "EMIT: type: #{type}, token: #{token}, text: #{text}, ts: #{ts}, te: #{te}"

    emit_literal if @literal

    if @block
      @block.call type, token, text, ts, te
    end

    @tokens << [type, token, text, ts, te]
  end

  # Centralizes and unifies the handling of validation related
  # errors.
  def self.validation_error(type, what, reason)
    case type
    when :group
      error = InvalidGroupError.new(what, reason)
    when :backref
      error = InvalidBackrefError.new(what, reason)
    when :sequence
      error = InvalidSequenceError.new(what, reason)
    else
      error = ValidationError.new('expression')
    end

    raise error # unless @@config.validation_ignore
  end

  # Used for references with an empty name or number
  def self.empty_backref_error(type, what)
    validation_error(:backref, what, 'ref ID is empty')
  end

  # Used for named expressions with an empty name
  def self.empty_name_error(type, what)
    validation_error(type, what, 'name is empty')
  end

end # module Regexp::Scanner
